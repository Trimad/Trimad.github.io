<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Processing on Hugo Grimoire</title><link>https://trimad.github.io/categories/processing/</link><description>Recent content in Processing on Hugo Grimoire</description><generator>Hugo -- gohugo.io</generator><lastBuildDate>Sat, 14 May 2022 00:00:00 +0000</lastBuildDate><atom:link href="https://trimad.github.io/categories/processing/index.xml" rel="self" type="application/rss+xml"/><item><title>Logistic Map</title><link>https://trimad.github.io/post/2022-05-14-logistic-map/</link><pubDate>Sat, 14 May 2022 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2022-05-14-logistic-map/</guid><description>
The logistic map is a mathematical model used to describe the population growth of a species over time. It is a simple equation that takes into account the effects of limited resources and environmental factors on population growth. The logistic map produces a pattern of population growth that exhibits chaotic behavior as the values of the model's parameters change, making it a valuable tool for studying complex systems.</description></item><item><title>k-means Clustering</title><link>https://trimad.github.io/post/2021-05-18-k-means-clustering/</link><pubDate>Tue, 18 May 2021 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2021-05-18-k-means-clustering/</guid><description>
_k-means clustering_ is a method of vector quantization, originally from signal processing, that aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean (cluster centers or cluster centroid), serving as a prototype of the cluster. This results in a partitioning of the data space into Voronoi cells.</description></item><item><title>Blending Textures With Open Simplex Noise</title><link>https://trimad.github.io/post/2019-08-18-blending-textures-with-open-simplex-noise/</link><pubDate>Sun, 18 Aug 2019 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2019-08-18-blending-textures-with-open-simplex-noise/</guid><description>
This Processing sketch loads two images and creates an image mask that blends them together. The transparency of the image mask is determined by 4D Open Simplex Noise, which loops perfectly.</description></item><item><title>Cube Wave</title><link>https://trimad.github.io/post/2018-12-30-cube-wave/</link><pubDate>Sun, 30 Dec 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-12-30-cube-wave/</guid><description>
Here's my take on... Daniel Shiffman's take on... Beesandbomb's take on the cube wave.</description></item><item><title>Lorenz Doll</title><link>https://trimad.github.io/post/2018-11-21-lorenz-doll/</link><pubDate>Wed, 21 Nov 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-11-21-lorenz-doll/</guid><description>
In this sketch I turned every pixel of an image into a Lorenz System. I mapped the velocity of that system to the brightness value of the pixel. This was the result. Sadly, the Processing sketch I made this with is gone forever.</description></item><item><title>Barnsley Fern</title><link>https://trimad.github.io/post/2018-06-28-barnsley-fern/</link><pubDate>Thu, 28 Jun 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-06-28-barnsley-fern/</guid><description>
The Barnsley Fern is a fractal pattern named after British mathematician Michael Barnsley. It is generated by an iterative process that involves repeatedly applying a set of geometric transformations to a simple initial shape. The resulting fern-like pattern displays self-similarity at different scales, and has applications in computer graphics, image compression, and chaos theory.</description></item><item><title>Kruskal's Algorithm Visualized With Processing</title><link>https://trimad.github.io/post/2018-04-11-kruskal-algorithm-processing/</link><pubDate>Wed, 11 Apr 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-04-11-kruskal-algorithm-processing/</guid><description>
Kruskal's algorithm is a greedy algorithm used to find the minimum spanning tree of a connected, weighted graph. The algorithm works by sorting the edges of the graph by weight, and then adding the edges to the minimum spanning tree one by one, making sure to avoid creating cycles. Kruskal's algorithm has a time complexity of O(E log E) where E is the number of edges in the graph, and is widely used in network design and optimization problems.</description></item><item><title>Collatz Conjecture + Unit Circle</title><link>https://trimad.github.io/post/2018-04-09-collatz-conjecture-unit-circle/</link><pubDate>Mon, 09 Apr 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-04-09-collatz-conjecture-unit-circle/</guid><description/></item><item><title>Minimum Spanning Tree Visualized</title><link>https://trimad.github.io/post/2018-04-07-minimum-spanning-tree-visualized/</link><pubDate>Sat, 07 Apr 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-04-07-minimum-spanning-tree-visualized/</guid><description/></item><item><title>AT&amp;T Hackathon</title><link>https://trimad.github.io/post/2018-03-12-att-hackathon/</link><pubDate>Mon, 12 Mar 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-03-12-att-hackathon/</guid><description/></item><item><title>Generating Terrain with Open Simplex Noise</title><link>https://trimad.github.io/post/2018-01-03-generating-terrain-with-open-simplex-noise/</link><pubDate>Wed, 03 Jan 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-01-03-generating-terrain-with-open-simplex-noise/</guid><description/></item><item><title>Open Simplex Noise</title><link>https://trimad.github.io/post/2018-01-02-open-simplex-noise/</link><pubDate>Tue, 02 Jan 2018 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2018-01-02-open-simplex-noise/</guid><description/></item><item><title>Flippy Tiles</title><link>https://trimad.github.io/post/2017-11-18-flippy-tiles/</link><pubDate>Sat, 18 Nov 2017 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2017-11-18-flippy-tiles/</guid><description/></item><item><title>Juno Cam Image Processing</title><link>https://trimad.github.io/post/2017-11-12-juno-cam-image-processing/</link><pubDate>Sun, 12 Nov 2017 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2017-11-12-juno-cam-image-processing/</guid><description/></item><item><title>Counting Sort</title><link>https://trimad.github.io/post/2017-07-18-counting-sort/</link><pubDate>Tue, 18 Jul 2017 00:00:00 +0000</pubDate><guid>https://trimad.github.io/post/2017-07-18-counting-sort/</guid><description>
1//int [] A = {2, 5, 3, 0, 2, 3, 0, 3}; 2int [] A = {6, 0, 2, 0, 1, 3, 4, 6, 1, 3, 2}; 3int []B = new int[A.length]; 4 5void setup() { 6 countingSort(A); 7 noLoop(); 8} 9 10void countingSort(int arr[]) { 11 12 int k = arr.length; 13 14 // The output character array that will have sorted arr 15 int output[] = new int[k]; 16 17 // Create a count array to store count of inidividual 18 // characters and initialize count array as 0 19 int count[] = new int[256]; 20 for (int i=0; i&amp;lt;256; ++i) 21 count[i] = 0; 22 23 // store count of each character 24 for (int i=0; i&amp;lt;k; ++i) { 25 ++count[arr[i]]; 26 print(count[i]); 27 } 28 // Change count[i] so that count[i] now contains actual 29 // position of this character in output array 30 for (int i=1; i&amp;lt;=255; ++i) { 31 count[i] += count[i-1]; 32 } 33 println(&amp;#34;&amp;#34;); 34 // Build the output character array 35 for (int i = 0; i&amp;lt;k; ++i) 36 { 37 output[count[arr[i]]-1] = arr[i]; 38 print(output[i]); 39 --count[arr[i]]; 40 } 41 println(&amp;#34;&amp;#34;); 42 // Copy the output array to arr, so that arr now 43 // contains sorted characters 44 for (int i = 0; i&amp;lt;k; ++i) { 45 arr[i] = output[i]; 46 print(output[i]); 47 } 48}</description></item></channel></rss>