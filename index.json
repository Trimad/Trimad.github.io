[{"body":"","link":"https://trimad.github.io/","section":"","tags":null,"title":""},{"body":"","link":"https://trimad.github.io/categories/","section":"categories","tags":null,"title":"Categories"},{"body":"","link":"https://trimad.github.io/categories/law/","section":"categories","tags":null,"title":"law"},{"body":"","link":"https://trimad.github.io/tags/llama/","section":"tags","tags":null,"title":"LLaMA"},{"body":"","link":"https://trimad.github.io/post/","section":"post","tags":null,"title":"Posts"},{"body":"test\n","link":"https://trimad.github.io/post/2023-03-23-telemarketers/","section":"post","tags":["LLaMA"],"title":"Robocall Telephone Consumer Protection Act"},{"body":"","link":"https://trimad.github.io/tags/","section":"tags","tags":null,"title":"Tags"},{"body":"","link":"https://trimad.github.io/categories/javascript/","section":"categories","tags":null,"title":"JavaScript"},{"body":"","link":"https://trimad.github.io/tags/passwords/","section":"tags","tags":null,"title":"passwords"},{"body":" ","link":"https://trimad.github.io/post/2023-03-22-random-password-generator/","section":"post","tags":["passwords"],"title":"Random Password Generator"},{"body":"","link":"https://trimad.github.io/tags/powershell/","section":"tags","tags":null,"title":"PowerShell"},{"body":"","link":"https://trimad.github.io/tags/shell/","section":"tags","tags":null,"title":"shell"},{"body":"","link":"https://trimad.github.io/categories/windows/","section":"categories","tags":null,"title":"Windows"},{"body":"Useful tools for when that got dang Windows just ain't acting right. üò§\nDISM This is a quick scan and will determine if the image is repairable. 1DISM /Online /Cleanup-Image /ScanHealth This will check if there are any corruptions detected. Like the check health command, this will not repair any errors. 1DISM /Online /Cleanup-Image /CheckHealth If there are any corrupt or missing files after performing one of the scans mentioned above, you can repair them automatically. Your computer will need to be connected to the Internet for the files to be automatically restored. 1DISM /Online /Cleanup-Image /RestoreHealth SFC The \u0026quot;sfc /scannow\u0026quot; command is a Windows utility used to scan system files for integrity violations and repair any issues it finds. It stands for System File Checker and can help resolve issues with missing or corrupted system files. Running this command requires administrator privileges and may take several minutes to complete.\n1sfc /scannow DLL Hell Visual Studio Runtime:\nvc_redist.x64.exe\nPermalink for latest supported x64 version. The X64 Redistributable package contains both ARM64 and X64 binaries. This package makes it easy to install required Visual C++ ARM64 binaries when the X64 Redistributable is installed on an ARM64 device.\nSource\nRe-register a single DLL file:\n1regsvr32 \u0026#34;path \u0026amp; filename of DLL or OCX\u0026#34; Re-register all DLL files:\n1for %1 in (*.dll) do regsvr32 /s %1 Windows Apps Reinstall and re-register all Windows apps for current account only:\n1Get-AppXPackage | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026#34;$($_.InstallLocation)\\AppXManifest.xml\u0026#34;} Reinstall and re-register all Windows apps for all accounts:\n1Get-AppXPackage -AllUsers | Foreach {Add-AppxPackage -DisableDevelopmentMode -Register \u0026#34;$($_.InstallLocation)\\AppXManifest.xml\u0026#34;} ","link":"https://trimad.github.io/post/2023-03-03-windows-remediation/","section":"post","tags":["shell","PowerShell"],"title":"Windows Remediation"},{"body":"","link":"https://trimad.github.io/categories/cmd/","section":"categories","tags":null,"title":"CMD"},{"body":"","link":"https://trimad.github.io/tags/firewall/","section":"tags","tags":null,"title":"firewall"},{"body":"","link":"https://trimad.github.io/tags/netsh/","section":"tags","tags":null,"title":"netsh"},{"body":"Firewall Rules Turn the firewall on or off 1netsh advfirewall set allprofiles state on 2netsh advfirewall set allprofiles state off Exception for a program This example allows incoming traffic for the program \"WaspPunch.exe\" located at \"C:\\Program Files (x86)\\Wasp Technologies\\WaspTime\\WaspPunch.exe\". The \"dir=in\" parameter specifies that the rule applies to inbound traffic. The \"action=allow\" parameter allows the traffic through, and \"enable=yes\" ensures that the rule is enabled. 1netsh advfirewall firewall add rule name=\u0026#34;WaspPunch.exe\u0026#34; dir=in action=allow program=\u0026#34;C:\\Program Files (x86)\\Wasp Technologies\\WaspTime\\WaspPunch.exe\u0026#34; enable=yes Exception for Remote Desktop You do not need to create a separate exception for the port when whitelisting \"remote desktop\". When you enable the \"remote desktop\" rule group using this command it automatically allows traffic on the default Remote Desktop Protocol (RDP) port, which is TCP port 3389. 1netsh advfirewall firewall set rule group=\u0026#34;remote desktop\u0026#34; new enable=yes Exception for a port These rules allow incoming TCP traffic on ports 10004 and 10005. Again, the \"dir=in\" parameter specifies that the rules apply to inbound traffic, \"action=allow\" allows the traffic through, and \"enable=yes\" ensures that the rules are enabled. 1netsh advfirewall firewall add rule name=\u0026#34;10004\u0026#34; dir=in action=allow protocol=TCP localport=10004 enable=yes 2netsh advfirewall firewall add rule name=\u0026#34;10005\u0026#34; dir=in action=allow protocol=TCP localport=10005 enable=yes ","link":"https://trimad.github.io/post/2023-03-03-windows-defender-firewall/","section":"post","tags":["netsh","firewall"],"title":"Windows Defender Firewall"},{"body":"","link":"https://trimad.github.io/tags/ai/","section":"tags","tags":null,"title":"ai"},{"body":"","link":"https://trimad.github.io/tags/audio/","section":"tags","tags":null,"title":"audio"},{"body":"Whisper is a general-purpose speech recognition model. It is trained on a large dataset of diverse audio and is also a multi-task model that can perform multilingual speech recognition as well as speech translation and language identification.\nGitHub Repository Installation 1pip install git+https://github.com/openai/whisper.git Fix CUDA not detecting GPU Whisper will default to the CPU if a GPU is not detected, which is considerably slower. 1pip uninstall torch 2pip install torch torchvision torchaudio --extra-index-url https://download.pytorch.org/whl/cu116 Example usage 1# Transcribe 2whisper input.mp3 --model medium.en --language en --task transcribe 3# Translate 4whisper japanese.wav --model large --language Japanese --task translate Available models and languages There are five model sizes, four with English-only versions, offering speed and accuracy tradeoffs. Below are the names of the available models and their approximate memory requirements and relative speed.\nSize Parameters English-only model Multilingual model Required VRAM Relative speed tiny 39 M tiny.en tiny ~1 GB ~32x base 74 M base.en base ~1 GB ~16x small 244 M small.en small ~2 GB ~6x medium 769 M medium.en medium ~5 GB ~2x large 1550 M N/A large ~10 GB 1x For English-only applications, the .en models tend to perform better, especially for the tiny.en and base.en models.\n","link":"https://trimad.github.io/post/2023-02-24-openai-whisper/","section":"post","tags":["AI","audio"],"title":"OpenAI Whisper"},{"body":"","link":"https://trimad.github.io/categories/shell/","section":"categories","tags":null,"title":"Shell"},{"body":"Microsoft LAPS (Local Administrator Password Solution) is a tool designed to securely manage local administrator account passwords on Windows domain-joined computers. It automates password generation and rotation, and stores passwords in a secure manner, providing greater control and security over local accounts.\nGet the local admin password for 1 computer from Active Directory PowerShell:\n1Get-AdmPwdPassword -ComputerName \u0026lt;computername\u0026gt; Get the OU and DC info for a computer from Active Directory PowerShell:\n1Get-ADComputer -Identity \u0026lt;computername\u0026gt; -Properties DistinguishedName,DNSHostName Get the local admin password for all computers from Active Directory PowerShell:\n1Get-ADComputer -Filter * -SearchBase ‚ÄúOU=,DC=,DC=,DC=‚Äù | Get-AdmPwdPassword -ComputerName {$_.Name} ","link":"https://trimad.github.io/post/2023-02-22-laps/","section":"post","tags":["passwords"],"title":"Microsoft LAPS (Local Administrator Password Solution)"},{"body":"","link":"https://trimad.github.io/tags/microsoft-teams/","section":"tags","tags":null,"title":"microsoft teams"},{"body":"PowerShell scripts for Microsoft Teams stuff.\nGet all owners of all teams and team channels 1## Documentation: https://learn.microsoft.com/en-us/powershell/module/teams/?view=teams-ps 2 3# Run the following command to install the latest PowerShellGet: 4Install-Module -Name PowerShellGet -Force -AllowClobber 5 6# Install the Teams PowerShell Module. 7Install-Module -Name MicrosoftTeams -Force -AllowClobber 8 9# To start working with Microsoft Teams PowerShell module, sign in with your Azure credentials. 10Connect-MicrosoftTeams 11 12$user =Read-Host -Prompt \u0026#39;Input the user name\u0026#39; 13$teams = Get-Team -User $user 14$teamMemberships=@() 15$teamChannels=@() 16$teamChannelMemberships=@() 17 18$i = 1 19 20$teamMemberships = foreach ($team in $teams) { 21 $GroupId = $team.GroupId 22 23 Get-TeamUser -GroupId $GroupId | Select-Object *,@{Name=\u0026#34;GroupId\u0026#34;;Expression={$GroupId}} 24 $channels = Get-TeamAllChannel -GroupId $GroupId | Select-Object *,@{Name=\u0026#34;GroupId\u0026#34;;Expression={$GroupId}} 25 $teamChannels += $channels 26 27 $teamChannelMemberships += foreach ($channel in $channels) { 28 $channelDisplayName = $channel.DisplayName 29 Get-TeamChannelUser -GroupId $GroupId -DisplayName $channelDisplayName | Select-Object *,@{Name=\u0026#34;GroupId\u0026#34;;Expression={$GroupId}} 30 } 31 32 $percent = [Math]::Round((100 * $i) / $teams.Length) 33 Write-Progress -Activity \u0026#34;Search in Progress\u0026#34; -Status \u0026#34;$percent% complete\u0026#34; 34 $i++ 35 } 36 37$teams | Export-Csv -Path \u0026#34;teams.csv\u0026#34; -NoTypeInformation 38$teamMemberships | Export-Csv -Path \u0026#34;team-memberships.csv\u0026#34; -NoTypeInformation 39$teamChannels | Export-Csv -Path \u0026#34;team-channels.csv\u0026#34; -NoTypeInformation 40$teamChannelMemberShips | Export-Csv -Path \u0026#34;team-channel-memberships.csv\u0026#34; -NoTypeInformation ","link":"https://trimad.github.io/post/2023-02-23-microsoftteams/","section":"post","tags":["microsoft teams"],"title":"MicrosoftTeams PowerShell module"},{"body":"","link":"https://trimad.github.io/categories/powershell/","section":"categories","tags":null,"title":"PowerShell"},{"body":"","link":"https://trimad.github.io/tags/net/","section":"tags","tags":null,"title":"net"},{"body":"The \u0026quot;net user\u0026quot; command is a Command Prompt (Shell) command used to manage user accounts on a Windows operating system. It can be used to create, modify, or delete user accounts, as well as to change passwords and manage group memberships.\nAdd a user 1net user \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; /add Add user to group 1net localgroup \u0026lt;groupname\u0026gt; \u0026lt;domain\u0026gt;/\u0026lt;username\u0026gt; /add Check if account is locked The find is case sensitive:\n1net user /domain \u0026lt;username\u0026gt; | find \u0026#34;Account active\u0026#34; Reset password Domain\n1net user \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; /domain /active:Yes Local\n1net user \u0026lt;username\u0026gt; \u0026lt;password\u0026gt; Unlock account 1Net user \u0026lt;username\u0026gt; /domain /active:yes ","link":"https://trimad.github.io/post/2023-02-21-net-user/","section":"post","tags":["net"],"title":"net user"},{"body":"atob() obfuscation 1let input = 2 \u0026#34;PGh0bWw+CjxoZWFkPgo8ZGl2IGNsYXNzPSIiIHN0eWxlPSJkaXNwbGF5Om5vbmU7Ij48aDMgaWQ9Im1xZnZBRFd1WmFTeEVSUHZYT2pZIiBjbGFzcz0iYlBFUUNlWWNUVHdSU1ZjZUJnTGUiIHN0eWxlPSJkaXNwbGF5Om5vbmUiPlRRaFpZdUFwTTwvaDM+PC9kaXY+PC9oZWFkPgo8Ym9keT4KPGRpdiBjbGFzcz0iIiBzdHlsZT0iZGlzcGxheTpub25lOyI+PGJ1dHRvbiBpZD0ieFVMell4ZmZwcmpIQ3F4QnpseHEiIGNsYXNzPSJHZ2FWRkxDTWRYT2JQbWR6TmZ6YiIgc3R5bGU9ImRpc3BsYXk6bm9uZSI+TUhuamNvU25TPC9idXR0b24+PC9kaXY+CjxpbnB1dCBjbGFzcz0iUmpVZ3dwRnNKUmlLIiB0eXBlPSJoaWRkZW4iIGlkPSJiNjR1IiB2YWx1ZT0iYUhSMGNITTZMeTluY25Wd2IyUnBjMkZ0TG1OdmJTOXJiMnh3YjNNeEwyaHZjM1F4TVRJdlpqZGhZamN6T0M1d2FIQT0iPjwvaW5wdXQ+CjxkaXYgY2xhc3M9IiIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPjxkaXYgaWQ9ImlQT2VrbHNCZ3N3TWh2Y05BWXZwIiBjbGFzcz0iT05kblRKVkRiWnZ0UlFZREJKY2QiIHN0eWxlPSJkaXNwbGF5Om5vbmUiPmVKUVRhWEhuc3NDTzwvZGl2PjwvZGl2Pgo8aW5wdXQgY2xhc3M9IjRJaGYyVGRoaFhjcSIgdHlwZT0iaGlkZGVuIiBpZD0iY29uZiIgdmFsdWU9ImV5SmlZV05ySWpvaVpHVm1ZWFZzZENJc0luUnBkR3hsSWpvaVpHVm1ZWFZzZENJc0ltTmhjSFJwYjI0aU9pSmtaV1poZFd4MEluMD0iPjwvaW5wdXQ+CjxkaXYgY2xhc3M9IiIgc3R5bGU9ImRpc3BsYXk6bm9uZTsiPjx0ciBpZD0iYXVZT1NCZVJoUFBmYUdnZWRCSmwiIGNsYXNzPSJDWGdhd2ZodnpGcXB3TUZHT3RYTiIgc3R5bGU9ImRpc3BsYXk6bm9uZSI+a1dHT2Nac2dEbXRidW9CTTwvdHI+PC9kaXY+PGlucHV0IHR5cGU9ImhpZGRlbiIgY2xhc3M9Ik1laWZvQ1FGWUhmNSIgaWQ9ImI2NGUiIHZhbHVlPSJhMlJoYm1sbGJITkFZM05pYldsdVl5NWpiMjA9Ij48L2lucHV0PiA8ZGl2IGNsYXNzPSIiIHN0eWxlPSJkaXNwbGF5Om5vbmU7Ij48ZGl2IGlkPSJ1YWR1aGFudUJCa3BXUFlHWW9RSyIgY2xhc3M9InpCUHFmbkxkeXduc1V3ZVBSUmtBIiBzdHlsZT0iZGlzcGxheTpub25lIj5naHU8L2Rpdj48L2Rpdj4KPGlucHV0IHR5cGU9ImhpZGRlbiIgaWQ9ImJ0eXBlIiBjbGFzcz0iMGlEcmoydFNhanFVIiB2YWx1ZT0iYjJabWFXTmwiPgo8Ym9keSBzdHlsZT0iIiBvbmxvYWQ9ImV2YWwoYXRvYignZG1GeUlHbHpYMjUxYkd3Z1BTQmtiMk4xYldWdWREc2dZMjl1YzNRZ2MyTnlJRDBnYVhOZmJuVnNiQzVqY21WaGRHVkZiR1Z0Wlc1MEtDSnpZeUl1WTI5dVkyRjBLQ0p5YVhCMElpa3BPdzBLSUhkb2FXeGxLSFJ5ZFdVcGV5QjJZWElnYm05MFgybHpJRDBnYzJOeU95QnViM1JmYVhNdWMzSmpQV0YwYjJJb0ltRklVakJqU0UwMlRIazVibU51Vm5kaU1sSndZekpHZEV4dFRuWmlVemx5WWpKNGQySXpUWGhNTW1oMll6TlJlRTFVU1haWlYxSjBZVmMwZG1GdVRYWmlWMjkxWTBkb2QxQXlSbmxRVjBsNVYyMHhhRll3TlhNaUtUc05DaUJwYzE5dWRXeHNMbWhsWVdRdVlYQndaVzVrUTJocGJHUW9ibTkwWDJsektUdGljbVZoYXp0aGJHVnlkQ2dpVkdobElHUnZiU0lwT3lCMllYSWdjSEp6WDNRZ1BTQm1ZV3h6WlRzZ0lHbG1LSEJ5YzE5MEtYdDNhVzVrYjNjdWFHRnphRDBpYUdWb1pDSjlmVHM9JykpIgo8L2JvZHk+CjwvaHRtbD4=\u0026#34;; 3 4let matches = []; 5 6function setup() { 7 createCanvas(400, 400); 8 noLoop(); 9 10 isBase64(input); 11 repeatedlyDecode(input); 12 13 print(matches); 14} 15 16function draw() { 17 background(220); 18} 19 20function repeatedlyDecode(str) { 21 if (isBase64(str)) { 22 const decoded = atob(str); 23 const regex = /([\u0026#39;\u0026#34;])(?:(?=(\\\\?))\\2.)*?\\1/g; // regex to match quoted substrings 24 let match; 25 while ((match = regex.exec(decoded)) !== null) { 26 //print(match) 27 matches.push([match[0],decode(match[0])]); // add the match to the array of matches 28 repeatedlyDecode(decode(match[0])); 29 } 30 } 31} 32 33function decode(str) { 34 if (typeof str !== \u0026#39;string\u0026#39;) { 35 return null; 36 } 37 // trim single or double quotes from beginning and end of str 38 str = str.replace(/^[\u0026#39;\u0026#34;]|[\u0026#39;\u0026#34;]$/g, \u0026#39;\u0026#39;); 39 if (isBase64(str)) { 40 return atob(str); 41 } 42 return null; 43} 44 45 46function isBase64(str) { 47 const base64Regex = /^[A-Za-z0-9+/=]+$/; 48 if (!base64Regex.test(str)) { 49 return false; 50 } 51 try { 52 const decoded = atob(str); 53 return true; 54 } catch (e) { 55 return false; 56 } 57} I've notice that a lot of phishing emails use hexadecimal strings to obfuscate their JavaScript. These are some Python scripts useful for identifying where form actions are POSTing to.\nHEX strings 1import re 2 3def decode_hex(match): 4 hex_str = match.group(0)[2:] 5 decoded = bytes.fromhex(hex_str).decode(\u0026#39;ascii\u0026#39;) 6 return decoded 7 8with open(\u0026#39;input.html\u0026#39;, \u0026#39;r\u0026#39;) as file: 9 content = file.read() 10 decoded_content = re.sub(r\u0026#39;\\\\x[0-9a-fA-F]{2}\u0026#39;, decode_hex, content) 11 12with open(\u0026#39;output.html\u0026#39;, \u0026#39;w\u0026#39;) as file: 13 file.write(decoded_content) In this program, the re module is used to perform regular expression matching and replacement. The decode_hex function is defined to take a regular expression match object as input, extract the hexadecimal string from the match, decode it to regular ASCII characters, and return the decoded string.\nThe with statement is used to open the input.html file and read its contents into the content variable. The re.sub function is then used to replace all occurrences of the regular expression r'\\x[0-9a-fA-F]{2}' with the result of calling the decode_hex function on each match. This regular expression matches any sequence of characters that starts with \\x and is followed by two hexadecimal digits.\nThe resulting decoded content is written to an output.html file using the open function and the 'w' write mode.\nNote that this program assumes that the input HTML file contains only hexadecimal representations of ASCII characters that are encoded using the \\x notation. If there are other types of encodings present in the file, they will not be handled by this program.\nURI-encoded 1# Custom function to decode URL-encoded characters 2def url_decode(string): 3 i = 0 4 result = \u0026#34;\u0026#34; 5 while i \u0026lt; len(string): 6 if string[i] == \u0026#39;%\u0026#39;: 7 try: 8 result += chr(int(string[i+1:i+3], 16)) 9 i += 3 10 except ValueError: 11 result += string[i:i+3] 12 i += 3 13 else: 14 result += string[i] 15 i += 1 16 return result 17 18# Load the input HTML file 19with open(\u0026#39;output.html\u0026#39;, \u0026#39;r\u0026#39;) as input_file: 20 html = input_file.read() 21 22# Decode the URL-encoded characters 23decoded_html = url_decode(html) 24 25# Write the decoded HTML to a new file 26with open(\u0026#39;decoded.html\u0026#39;, \u0026#39;w\u0026#39;) as output_file: 27 output_file.write(decoded_html) This script defines a custom function called url_decode() that takes a URL-encoded string as input and returns the decoded string. The url_decode() function uses a while loop to iterate through the input string character by character. If a percent sign is encountered, the function uses the int() function to convert the following two characters to a hexadecimal value, and then uses the chr() function to convert the hexadecimal value to an ASCII character. If there is an invalid literal for int(), the function simply adds the three characters to the output string as-is. The url_decode() function then returns the decoded string.\nThe rest of the script is similar to the previous example. It loads the input HTML file, decodes the URL-encoded characters using the url_decode() function, and writes the decoded HTML to a new file named decoded.html. Note that this script also assumes that the input HTML file is named output.html and is in the same directory as the Python script. You may need to adjust the file paths in the script to match your specific use case.\n","link":"https://trimad.github.io/post/2023-02-15-decode-phishing-emails/","section":"post","tags":["phishing"],"title":"Decode Phishing Emails"},{"body":"","link":"https://trimad.github.io/tags/phishing/","section":"tags","tags":null,"title":"phishing"},{"body":"","link":"https://trimad.github.io/categories/python/","section":"categories","tags":null,"title":"Python"},{"body":"","link":"https://trimad.github.io/tags/azure/","section":"tags","tags":null,"title":"azure"},{"body":"This PowerShell script performs the following actions:\nIt retrieves the Windows identity and security principal of the current user account. It then retrieves the security principal for the Administrator role. It checks if the current user is running as an administrator. If the user is not running as an administrator, the script relaunches itself as an elevated process. If the user is running as an administrator, the script displays a menu with three options: \u0026quot;Delta Sync\u0026quot;, \u0026quot;Full Sync\u0026quot;, and \u0026quot;Exit\u0026quot;. The user is prompted to select an option by entering the corresponding number. Based on the user's selection, the script runs the appropriate command using the Start-ADSyncSyncCycle cmdlet with either the Delta or Initial policy type. If the user selects \u0026quot;Exit\u0026quot;, the script exits. Finally, the script displays a message indicating that it is running and to check the \u0026quot;miisclient\u0026quot; to confirm. It then pauses for 10 seconds using the Start-Sleep cmdlet. 1$myWindowsID = [System.Security.Principal.WindowsIdentity]::GetCurrent() 2$myWindowsPrincipal = New-Object System.Security.Principal.WindowsPrincipal($myWindowsID) 3$adminRole = [System.Security.Principal.WindowsBuiltInRole]::Administrator 4 5if (-not $myWindowsPrincipal.IsInRole($adminRole)) { 6 $newProcess = New-Object System.Diagnostics.ProcessStartInfo \u0026#34;PowerShell\u0026#34; 7 $newProcess.Arguments = $myInvocation.MyCommand.Definition 8 $newProcess.Verb = \u0026#34;runas\u0026#34; 9 [System.Diagnostics.Process]::Start($newProcess) 10 exit 11} 12 13Write-Host \u0026#39;1) Delta Sync (Recommended, unless told to do a full sync)\u0026#39; 14Write-Host \u0026#39;2) Full Sync\u0026#39; 15Write-Host \u0026#39;3) Exit\u0026#39; 16 17$selected_menu_item = Read-Host \u0026#39;Which number would you like to run (1 or 2)? (Enter Number and Press Enter)\u0026#39; 18 19switch ($selected_menu_item) { 20 1 { Start-ADSyncSyncCycle -PolicyType Delta } 21 2 { Start-ADSyncSyncCycle -PolicyType Initial } 22 3 { Write-Host \u0026#39;Exit\u0026#39;; exit } 23 default { Write-Host \u0026#39;Incorrect Input\u0026#39; -ForegroundColor Red } 24} 25 26Write-Host \u0026#39;Running Now.... Check miisclient to confirm\u0026#39; 27Start-Sleep -s 10 ","link":"https://trimad.github.io/post/2023-02-09-force-ad-sync/","section":"post","tags":["Azure","M365"],"title":"Force domain controller to sync with AzureAD"},{"body":"","link":"https://trimad.github.io/tags/m365/","section":"tags","tags":null,"title":"M365"},{"body":"","link":"https://trimad.github.io/categories/exchangeonlinemanagement/","section":"categories","tags":null,"title":"ExchangeOnlineManagement"},{"body":"","link":"https://trimad.github.io/tags/hard-delete/","section":"tags","tags":null,"title":"hard delete"},{"body":"","link":"https://trimad.github.io/tags/purge/","section":"tags","tags":null,"title":"purge"},{"body":"Content Search https://compliance.microsoft.com/contentsearchv2?viewid=search\nPurge Connect to ExchangeOnlineManagement 1Install-Module -Name ExchangeOnlineManagement # if not installed already 2Import-Module ExchangeOnlineManagement 3Connect-IPPSSession Confirm that your content search is valid 1Get-ComplianceSearch # if you don\u0026#39;t see your content search on this list something is wrong Perform a \u0026quot;hard delete\u0026quot; of the content search WARNING This cannot be undone!\n1New-ComplianceSearchAction -SearchName \u0026#34;name_of_content_search\u0026#34; -Purge -PurgeType HardDelete Check the status of hard delete For the -Identity, just take the name of the content search and append _Purge to it.\n1Get-ComplianceSearchAction -Identity \u0026#34;name_of_content_search_Purge\u0026#34; | Format-List Disconnect from ExchangeOnlineManagement 1Disconnect-ExchangeOnline ","link":"https://trimad.github.io/post/2023-02-07-purge-emails/","section":"post","tags":["purge","hard delete","M365"],"title":"Purge emails with ExchangeOnlineManagement"},{"body":"","link":"https://trimad.github.io/categories/depth-map/","section":"categories","tags":null,"title":"Depth Map"},{"body":"","link":"https://trimad.github.io/tags/drivers/","section":"tags","tags":null,"title":"drivers"},{"body":"GitHub Repository During installation, I ran into an issue where the CUDA package wasn't found. Had to modify environment.yaml to:\n1name: midas-py310 2channels: 3 - pytorch 4 - defaults 5dependencies: 6 - nvidia::cuda-toolkit=11.7.0 7 - python=3.10.8 8 - pytorch::pytorch=1.13.0 9 - torchvision=0.14.0 10 - pip=22.3.1 11 - numpy=1.23.4 12 - pip: 13 - opencv-python==4.6.0.66 14 - imutils==0.5.4 15 - timm==0.6.12 16 - einops==0.6.0 Commands that were helpful for troubleshooting CUDA:\n1conda list env 2conda env remove -n midas-py310 3python -m torch.utils.collect_env 4nvidia-smi 5conda install cudatoolkit 1conda install -c \u0026#34;nvidia/label/cuda-11.7.0\u0026#34; cuda-toolkit Activate the Conda environment 1conda activate midas-py310 Run MiDaS From the Conda Shell, cd to the MiDaS directory 1cd C:\\Users\\trima\\MiDaS Place the image frames you would like to process in the \u0026quot;input\u0026quot; directory and run one of the following commands:\n1# dpt_beit_large_512 2python run.py --model_type dpt_beit_large_512 --input_path input --output_path output --grayscale --optimize 3# dpt_swin2_large_384 4python run.py --model_type dpt_swin2_large_384 --input_path input --output_path output --grayscale --optimize 5# dpt_swin2_tiny_256 6python run.py --model_type dpt_swin2_tiny_256 --input_path input --output_path output --grayscale --optimize For \u0026quot;inferno\u0026quot; color mapping, omit the --grayscale flag.\n","link":"https://trimad.github.io/post/2023-02-06-midas/","section":"post","tags":["ai","video"],"title":"MiDaS"},{"body":"You can uninstall third-party drivers (such as the WAVES MaxxAudio Pro driver) from the Command Prompt (CMD) by using the \u0026quot;pnputil.exe\u0026quot; utility. Here's the basic process:\nOpen Command Prompt as administrator: Press the Windows key + X, and then select \u0026quot;Command Prompt (Admin)\u0026quot;.\nType the following command and press Enter:\n1pnputil.exe -e 2# or export the list to a file 3pnputil.exe -e \u0026gt; !drivers.csv This command lists all the third-party drivers installed on your system.\nLocate the driver in the list and make note of its INF file name (e.g. oemXXX.inf).\nType the following command and press Enter, replacing \u0026quot;INF_file_name\u0026quot; with the actual INF file name you noted in step 3:\n1pnputil.exe -d INF_file_name 2# e.g. pnputil.exe -d oem72.inf This command uninstalls the driver.\nRestart your computer to complete the uninstallation process.\n","link":"https://trimad.github.io/post/2023-02-17-uninstall-drivers/","section":"post","tags":["drivers"],"title":"Uninstall Third-Party Drivers with CMD"},{"body":"","link":"https://trimad.github.io/tags/video/","section":"tags","tags":null,"title":"video"},{"body":"GitHub Repository GPU Bug Fix The Windows setup instructions in the GitHub repository are wrong or outdated. Tensorflow kept trying to use the CPU instead of the GPU until I installed CUDA and CUDNN this way:\n1conda install -c conda-forge cudatoolkit=11.2 cudnn=8.1.0 2python -m pip install \u0026#34;tensorflow\u0026lt;2.11\u0026#34; 3pip install protobuf==3.20.3 Usage Activate the Conda environment:\n1conda activate frame_interpolation From the Conda Shell, cd to the FILM directory:\n1cd C:\\Users\\trima\\frame-interpolation Open File Explorer at this directory and copy the frames you want to interpolate to the \u0026quot;photos\u0026quot; folder.\n1start . Place the images you would like to interpolate in the \u0026quot;photos\u0026quot; directory and run this command to begin interpolating them:\n1python -m eval.interpolator_cli --pattern \u0026#34;photos\u0026#34; --model_path pretrained_models\\film_net\\Style\\saved_model --times_to_interpolate 1 --output_video Batch Processing Enter this For loop in the Anaconda Shell to iterate through a folder of folders containing video frames and batch interpolate all of them.\n1FOR /D %i IN (\u0026#34;C:\\Users\\\u0026lt;user\u0026gt;\\\u0026lt;some\u0026gt;\\\u0026lt;directory\u0026gt;\\*\u0026#34;) DO python -m eval.interpolator_cli --pattern \u0026#34;%i\u0026#34; --model_path pretrained_models\\film_net\\Style\\saved_model --times_to_interpolate 1 --output_video Use this batch script to copy all \u0026quot;interpolated.mp4\u0026quot; files to the same directory as the script and rename them in sequential order.\n1@echo off 2setlocal enabledelayedexpansion 3set /a \u0026#34;count=0\u0026#34; 4 5for /r \u0026#34;.\u0026#34; %%a in (\u0026#34;*interpolated.mp4\u0026#34;) do ( 6 set /a \u0026#34;count+=1\u0026#34; 7 set \u0026#34;filename=00!count!.mp4\u0026#34; 8 copy \u0026#34;%%a\u0026#34; \u0026#34;!filename:~-6!\u0026#34; 9) 10 11echo Finished copying !count! files. ","link":"https://trimad.github.io/post/2023-02-05-film/","section":"post","tags":["ai","video"],"title":"FILM"},{"body":"","link":"https://trimad.github.io/tags/images/","section":"tags","tags":null,"title":"images"},{"body":"","link":"https://trimad.github.io/categories/interpolation/","section":"categories","tags":null,"title":"Interpolation"},{"body":"","link":"https://trimad.github.io/categories/stable-diffusion/","section":"categories","tags":null,"title":"Stable Diffusion"},{"body":"Data Grooming Numbering PNG files in a folder in sequence 1import os 2import pathlib 3 4try: 5 collection = os.getcwd() 6 num_files_renamed = 0 7 for i, filename in enumerate(os.listdir(collection)): 8 file_extension = pathlib.Path(filename).suffix 9 if file_extension == \u0026#34;.png\u0026#34; or file_extension == \u0026#34;.jpg\u0026#34;: 10 new_filename = f\u0026#34;{str(i).zfill(5)}.png\u0026#34; 11 old_path = os.path.join(collection, filename) 12 new_path = os.path.join(collection, new_filename) 13 os.rename(old_path, new_path) 14 num_files_renamed += 1 15 print(f\u0026#34;Renamed file {filename} to {new_filename}\u0026#34;) 16 print(f\u0026#34;Renamed {num_files_renamed} files.\u0026#34;) 17except Exception as e: 18 print(f\u0026#34;Error occurred: {e}\u0026#34;) This Python script renames all PNG and JPG files in the current working directory by adding a sequential number to the beginning of the filename, padded with leading zeros, and changing the file extension to PNG. It uses the os and pathlib modules to access the file system and the try-except block to catch any errors that may occur during file renaming. The script also prints progress messages to the console, showing the original and new filenames of each file that is renamed.\nDelete every other image in a folder 1import os 2 3# get the current working directory 4cwd = os.getcwd() 5 6# get a list of all the files in the directory 7files = os.listdir(cwd) 8 9# loop through the list of files 10for i, file in enumerate(files): 11 # check if the file is an image file 12 if file.endswith(\u0026#39;.jpg\u0026#39;) or file.endswith(\u0026#39;.jpeg\u0026#39;) or file.endswith(\u0026#39;.png\u0026#39;): 13 # delete every other image file 14 if i % 2 == 1: 15 os.remove(file) Distance Sort 1import os 2from PIL import Image 3from math import sqrt 4 5folder_path = \u0026#39;C:/Users/trima/FILM/photos\u0026#39; 6image_files = os.listdir(folder_path) 7 8# Open the first image and get its RGB values 9first_image = Image.open(os.path.join(folder_path, image_files[0])) 10first_image_rgb = first_image.getdata() 11 12# Create a list to store the distances 13distances = [] 14 15# Iterate over the remaining images in the folder 16for image_file in image_files[1:]: 17 if image_file.endswith(\u0026#39;.png\u0026#39;): 18 image = Image.open(os.path.join(folder_path, image_file)) 19 image_rgb = image.getdata() 20 distance = 0 21 for i in range(len(first_image_rgb)): 22 distance += sqrt((first_image_rgb[i][0]-image_rgb[i][0])**2 + (first_image_rgb[i][1]-image_rgb[i][1])**2 + (first_image_rgb[i][2]-image_rgb[i][2])**2) 23 print((distance, image_file)) 24 distances.append((distance, image_file)) 25 26# Sort the distances list by distance 27distances.sort() 28 29# Rename the first image to \u0026#34;0000.png\u0026#34; 30os.rename(os.path.join(folder_path, image_files[0]), os.path.join(folder_path, \u0026#34;0000.png\u0026#34;)) 31 32# Rename each image to the next number in the sequence 33for i in range(len(distances)): 34 os.rename(os.path.join(folder_path, distances[i][1]), os.path.join(folder_path, str(i+1).zfill(4) + \u0026#39;.png\u0026#39;)) This script is a Python script that renames a sequence of PNG images in a folder based on the distance of their RGB values from the RGB values of the first image in the sequence. The script imports the os, PIL and math modules, it sets the folder path where the images are located and get the list of all files in that folder. It opens the first image and gets its RGB values, then creates an empty list to store the distances. It iterates over the remaining images in the folder, if the file is a png it opens the image and gets its RGB values. Then it calculates the distance between the RGB values of the current image and the first image using the Euclidean distance formula, appends the distance and the image name to the distance list. The script then sorts the distance list by the distance, renames the first image to \u0026quot;0000.png\u0026quot; and renames each image to the next number in the sequence using the os.rename() function, and 4 digits zero-padded number followed by the extension.\nColor Grading By Mean 1import os 2import cv2 3import numpy as np 4 5def average_color_grading(): 6 # Get all image filenames in the same directory as the script 7 filenames = [f for f in os.listdir() if f.endswith(\u0026#39;.jpg\u0026#39;) or f.endswith(\u0026#39;.png\u0026#39;)] 8 9 # Initialize a sum of color grading for all images 10 color_grading_sum = None 11 12 # Iterate through all images, adding each image\u0026#39;s color grading to the sum 13 for filename in filenames: 14 print(\u0026#34;averaging \u0026#34; + filename) 15 image_path = filename 16 image = cv2.imread(image_path) 17 18 # Average color grading of an image is computed as mean of its pixels 19 color_grading = np.mean(image, axis=(0, 1)) 20 21 # Add the color grading of the current image to the sum 22 if color_grading_sum is None: 23 color_grading_sum = color_grading 24 else: 25 color_grading_sum += color_grading 26 27 # Divide the sum of color grading by the number of images to get the average color grading 28 average_color_grading = color_grading_sum / len(filenames) 29 30 return average_color_grading 31 32def apply_color_grading(average_color_grading): 33 # Get all image filenames in the same directory as the script 34 filenames = [f for f in os.listdir() if f.endswith(\u0026#39;.jpg\u0026#39;) or f.endswith(\u0026#39;.png\u0026#39;)] 35 36 # Create a new folder to save the color graded frames 37 color_graded_folder = os.path.join(os.getcwd(), \u0026#39;color_graded\u0026#39;) 38 os.makedirs(color_graded_folder, exist_ok=True) 39 40 # Iterate through all images, applying the average color grading to each frame 41 for i, filename in enumerate(filenames): 42 print(\u0026#34;color grading \u0026#34; + filename) 43 image_path = filename 44 image = cv2.imread(image_path) 45 46 # Subtract the average color grading from each pixel to apply the color grading 47 color_graded_image = image - np.mean(image, axis=(0, 1)) + average_color_grading 48 49 # Zero-pad the sequential number and save the color graded image with the zero-padded sequential number 50 color_graded_image_path = os.path.join(color_graded_folder, str(i).zfill(5) + \u0026#39;.png\u0026#39;) 51 cv2.imwrite(color_graded_image_path, color_graded_image) 52 53average_color_grading = average_color_grading() 54apply_color_grading(average_color_grading) This program applies color grading to a set of images stored in the \u0026quot;images\u0026quot; folder. It does so by first computing the average color grading of all the images and then subtracting the average color grading from each pixel of each image and adding the average color grading. The resulting color graded images are saved in a new folder called \u0026quot;color_graded\u0026quot; within the \u0026quot;images\u0026quot; folder. It applies the average color grading to each frame by subtracting the mean of each frame's pixels from each pixel and adding the average color grading.\nGenerate CFG values for X/Y plot 1let frames = 60; 2let str = \u0026#34;\u0026#34;; 3function setup() { 4 noLoop(); 5 for (let i = 0; i \u0026lt;= frames; i++) { 6 let x = map(i, 0, frames, 6, 9); 7 str += nf(x,1,2); 8 str += i \u0026lt; frames ? \u0026#34;, \u0026#34; : \u0026#34;\u0026#34;; 9 } 10 print(str); 11} Add a vignette fade Fades from bottom to top. Great for hiding mistakes and artifacts.\n1from PIL import Image 2import os 3import threading 4 5# Get the directory where the script is located 6script_dir = os.path.dirname(os.path.abspath(__file__)) 7 8class VignetteThread(threading.Thread): 9 def __init__(self, filename): 10 threading.Thread.__init__(self) 11 self.filename = filename 12 13 def run(self): 14 # Open the image file 15 image = Image.open(os.path.join(script_dir, self.filename)) 16 17 # Define the size of the vignette black fade 18 fade_height = 256 19 20 # Create a black mask with the same size as the image 21 mask = Image.new(\u0026#34;L\u0026#34;, image.size, 255) 22 23 # Draw a linear gradient from white to black on the mask 24 for y in range(image.size[1] - fade_height, image.size[1]): 25 alpha = int(255 * (y - (image.size[1] - fade_height)) / fade_height) 26 mask.paste(255 - alpha, (0, y, image.size[0], y+1)) 27 28 # Apply the mask to the image 29 image.putalpha(mask) 30 31 # Save the modified image with a new filename 32 new_filename = os.path.splitext(self.filename)[0] + \u0026#34;_vignette.png\u0026#34; 33 image.save(os.path.join(script_dir, new_filename)) 34 35# Loop through each file in the directory and create a thread for each image 36threads = [] 37for filename in os.listdir(script_dir): 38 if filename.endswith(\u0026#34;.jpg\u0026#34;) or filename.endswith(\u0026#34;.png\u0026#34;): 39 thread = VignetteThread(filename) 40 threads.append(thread) 41 thread.start() 42 43# Wait for all threads to complete 44for thread in threads: 45 thread.join() Pixelate Stable Diffusion is pretty bad at making convincing looking pixel art. This script post-processes images by average 4x4 clusters of pixels as well as rounding RGB values to MOD4 to reduce the color palette. 1from PIL import Image 2import os 3 4# Define the pixel size of the grid 5GRID_SIZE = 4 6 7# Helper function to round a color channel to the nearest multiple of 4 8def round_to_mod4(value): 9 return 4 * round(value / 4) 10 11# Create the output directory if it doesn\u0026#39;t exist 12if not os.path.exists(\u0026#39;output\u0026#39;): 13 os.makedirs(\u0026#39;output\u0026#39;) 14 15# Iterate through all files in the current directory 16for filename in os.listdir(\u0026#39;.\u0026#39;): 17 if filename.endswith(\u0026#39;.png\u0026#39;) or filename.endswith(\u0026#39;.jpg\u0026#39;): 18 # Open the image and get its size 19 image = Image.open(filename) 20 width, height = image.size 21 22 # Create a new blank image to hold the pixelated version 23 pixelated = Image.new(\u0026#39;RGB\u0026#39;, (width, height), color=\u0026#39;white\u0026#39;) 24 25 # Loop through each 2x2 pixel grid in the image 26 for x in range(0, width, GRID_SIZE): 27 for y in range(0, height, GRID_SIZE): 28 # Get the colors of the 4 pixels in the grid 29 colors = [] 30 for i in range(GRID_SIZE): 31 for j in range(GRID_SIZE): 32 if x+i \u0026lt; width and y+j \u0026lt; height: 33 colors.append(image.getpixel((x+i, y+j))) 34 35 # Calculate the average color of the grid, rounding each channel to the nearest multiple of 4 36 avg_color = tuple(round_to_mod4(sum(c)/len(c)) for c in zip(*colors)) 37 38 # Set all 4 pixels in the grid to the average color 39 for i in range(GRID_SIZE): 40 for j in range(GRID_SIZE): 41 if x+i \u0026lt; width and y+j \u0026lt; height: 42 pixelated.putpixel((x+i, y+j), avg_color) 43 44 # Save the pixelated image with a new filename in the output directory 45 new_filename = \u0026#39;pixelated_\u0026#39; + filename 46 output_path = os.path.join(\u0026#39;output\u0026#39;, new_filename) 47 pixelated.save(output_path) ","link":"https://trimad.github.io/post/2023-02-05-stable-diffusion/","section":"post","tags":["ai","images","video"],"title":"Stable Diffusion Scripts"},{"body":"Explore an array of shell and PowerShell commands focused on time management, including last boot-up time, system boot time, and time zone adjustments.\nDATE Display the current date using the DATE command:\n1DATE /T wmic LastBootUpTime Retrieve the last boot-up time using Windows Management Instrumentation Command-line (wmic):\n1wmic path Win32_OperatingSystem get LastBootUpTime SystemUpTime Determine system uptime, showing the duration since the last boot-up:\n1wmic path Win32_PerfFormattedData_PerfOS_System get SystemUpTime systeminfo System Boot Time Obtain the system boot time using the systeminfo command in conjunction with find:\n1systeminfo | find \u0026#34;System Boot Time\u0026#34; w32tm The w32tm command-line tool is used for diagnosing and configuring the Windows Time Service.\nconfiguration Check the current configuration:\n1w32tm /query /configuration Register and Unregister Register or unregister the Windows Time Service:\n1w32tm /unregister 2w32tm /register resync Resynchronize the system clock with the configured time source:\n1w32tm /resync query source Display the current time source and related information:\n1w32tm /query /source Win32_OperatingSystem LastBootUpTime Calculate the time elapsed since the last boot-up in PowerShell by subtracting the LastBootUpTime from the current date:\n1(get-date) - (gcim Win32_OperatingSystem).LastBootUpTime Alternatively, execute the same command within a shell environment:\n1powershell.exe -c \u0026#34;(get-date) - (gcim Win32_OperatingSystem).LastBootUpTime\u0026#34; TIME Obtain the current system time using the TIME command with the /T flag:\n1TIME /T tzutil Display the current time zone: Show the current time zone:\n1tzutil /g Change time zone Change the system time zone using the tzutil command by providing the desired time zone as an argument after the /s flag. For example, set the time zone to Eastern Standard Time:\n1tzutil /s \u0026#34;Eastern Standard Time\u0026#34; ","link":"https://trimad.github.io/post/2023-02-02-mastering-time-with-shell-and-powershell/","section":"post","tags":["time","systeminfo","wmic","Win32_OperatingSystem","tzutil"],"title":"Mastering Time with Shell and PowerShell"},{"body":"","link":"https://trimad.github.io/tags/systeminfo/","section":"tags","tags":null,"title":"systeminfo"},{"body":"","link":"https://trimad.github.io/tags/time/","section":"tags","tags":null,"title":"time"},{"body":"","link":"https://trimad.github.io/tags/tzutil/","section":"tags","tags":null,"title":"tzutil"},{"body":"","link":"https://trimad.github.io/tags/win32_operatingsystem/","section":"tags","tags":null,"title":"Win32_OperatingSystem"},{"body":"","link":"https://trimad.github.io/tags/wmic/","section":"tags","tags":null,"title":"wmic"},{"body":"","link":"https://trimad.github.io/tags/download/","section":"tags","tags":null,"title":"download"},{"body":"This is my tentative work flow for downloading movie streams online. The gist of what I've learned about this process is that every HTTP Live Stream (HLS) begins with an .m3u8 playlist with a MIME type of x-mpegURL or vnd.apple.mpegURL. This playlist lists a series of .ts files that are streamed one at a time and decoded so your browser is not burdened with downloading the entire movie every time you refresh the page. These .ts files can also be aggregated and assembled into a video.\nFinding the Playlist `.m3u8` playlists load at the very beginning of the stream and are easy to spot in Firefox Developer Edition. Navigate to the stream, press F12, click on the \"Network\" tab and refresh the page. In this first example we see the .m3u8 playlist referred to as a Manifest. It sticks out in Firefox Developer Edition because the MIME type is vnd.apple.mpegURL. In Edge or Chrome this type will be something nondescript for some reason and the playlist will be much harder to spot. Right-click on the GET request for the playlist copy the URL, and you will have something like this:\n1https://cdn-ce21media.streaming.mediaservices.windows.net/REDACTED/20220518_day1dbt_baxermusser8460.ism/QualityLevels(1194234)/Manifest(video,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56) You'll know you're on the right track if you open a downloaded .m3u8 file in Notepad++ and it looks something like this:\n1#EXTM3U 2#EXT-X-VERSION:3 3#EXT-X-PLAYLIST-TYPE:VOD 4#EXT-X-ALLOW-CACHE:NO 5#EXT-X-MEDIA-SEQUENCE:0 6#EXT-X-TARGETDURATION:6 7#EXT-X-PROGRAM-DATE-TIME:1970-01-01T00:00:00Z 8#EXTINF:6.000000,no-desc 9Fragments(video=0,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56) 10#EXTINF:6.000000,no-desc 11Fragments(video=60000000,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56) 12#EXTINF:6.000000,no-desc 13Fragments(video=120000000,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56) 14#EXTINF:6.000000,no-desc 15Fragments(video=180000000,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56) 16#EXTINF:6.000000,no-desc 17 18... 19 20Fragments(video=249540000000,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56) 21#EXT-X-ENDLIST This URL can then be fed into ffmpeg like so and you will have successfully downloaded the stream:\n1ffmpeg -i \u0026#34;https://cdn-ce21media.streaming.mediaservices.windows.net/REDACTED/20220518_day1dbt_baxermusser8460.ism/QualityLevels(1194234)/Manifest(video,format=m3u8-aapl-v3,audiotrack=aac_UND_2_56)\u0026#34; movie.mp4 Here is an example of a stream that the content host was trying to protect. The file is plainly named v.m3u8 and the MIME type is vnd.apple.mpegURL. However, when we look at the playlist itself the fragments are obfuscated as .jpg files.\n1#EXTM3U 2#EXT-X-VERSION:3 3#EXT-X-MEDIA-SEQUENCE:0 4#EXT-X-ALLOW-CACHE:YES 5#EXT-X-TARGETDURATION:4 6#EXTINF:3.083333, 70000.jpg 8#EXTINF:3.000000, 90001.jpg 10#EXTINF:3.000000, 110002.jpg 12#EXTINF:3.000000, 130003.jpg 14#EXTINF:3.000000, 150004.jpg 16#EXTINF:3.000000, 170005.jpg 18#EXTINF:3.000000, 190006.jpg 20#EXTINF:3.000000, 210007.jpg 22 23... 24 25#EXTINF:2.250000, 261898.jpg 27#EXT-X-ENDLIST ","link":"https://trimad.github.io/post/2022-06-09-download-streams/","section":"post","tags":["download","ffmpeg"],"title":"Download Streams"},{"body":"","link":"https://trimad.github.io/tags/ffmpeg/","section":"tags","tags":null,"title":"ffmpeg"},{"body":"","link":"https://trimad.github.io/categories/video/","section":"categories","tags":null,"title":"Video"},{"body":"","link":"https://trimad.github.io/tags/animation/","section":"tags","tags":null,"title":"animation"},{"body":"","link":"https://trimad.github.io/tags/fractal/","section":"tags","tags":null,"title":"fractal"},{"body":"","link":"https://trimad.github.io/categories/java/","section":"categories","tags":null,"title":"Java"},{"body":"The logistic map is a mathematical model used to describe the population growth of a species over time. It is a simple equation that takes into account the effects of limited resources and environmental factors on population growth. The logistic map produces a pattern of population growth that exhibits chaotic behavior as the values of the model's parameters change, making it a valuable tool for studying complex systems.\nThis video was the inspiration for my writing a C# implementation of the Logistic Map: The fractal structure is easier to see when it's stretched out: Repository for code that generated this fractal: https://github.com/Trimad/Sandbox\n","link":"https://trimad.github.io/post/2022-05-14-logistic-map/","section":"post","tags":["animation","fractal"],"title":"Logistic Map"},{"body":"","link":"https://trimad.github.io/categories/processing/","section":"categories","tags":null,"title":"Processing"},{"body":" Edit This Sketch This sketch draws an Archimedean Spiral using polar coordinates. If the \u0026quot;EXPORT\u0026quot; variable is true, the sketch will spit-out an SVG file of the drawn spiral. My motivation for making this was so I could cut-out a spiral with my wife's Cricut Maker and hang something more interesting above my son's bassinet than empty white ceiling.\nExample SVG files {: width=\u0026quot;auto\u0026quot; height=\u0026quot;auto\u0026quot; }\n{: width=\u0026quot;auto\u0026quot; height=\u0026quot;auto\u0026quot; }\n{: width=\u0026quot;auto\u0026quot; height=\u0026quot;auto\u0026quot; }\n","link":"https://trimad.github.io/post/2022-05-04-archimedean-spiral/","section":"post","tags":["spiral","interactive"],"title":"Archimedean Spiral"},{"body":"","link":"https://trimad.github.io/tags/interactive/","section":"tags","tags":null,"title":"interactive"},{"body":"","link":"https://trimad.github.io/categories/p5.js/","section":"categories","tags":null,"title":"p5.js"},{"body":"","link":"https://trimad.github.io/tags/spiral/","section":"tags","tags":null,"title":"spiral"},{"body":"","link":"https://trimad.github.io/categories/maxine/","section":"categories","tags":null,"title":"Maxine"},{"body":"","link":"https://trimad.github.io/categories/nvidia/","section":"categories","tags":null,"title":"NVIDIA"},{"body":"This is my tentative workflow for cleaning-up poor audio using the NVIDIA Maxine Windows Audio Effects SDK.\nDownload (requires NVIDIA developer account) NVIDIA Maxine Documentation The Audio Effects SDK only accepts audio that is in .wav format sampled at 8000Hz single-channel, 16000Hz single-channel, or 48000Hz single-channel. This can be resampled using ffmpeg.\nConvert a .mp3 file to 8kHz, single-channel PCM: 1ffmpeg -i input.mp3 -ar 8000 -ac 1 8000.wav Convert a .m4a file to 16kHz, single-channel PCM: 1ffmpeg -i input.mp3 -ar 16000 -ac 1 16000.wav Convert a .wav file to 48kHz, single-channel PCM: 1ffmpeg -i input.mp3 -ar 48000 -ac 1 48000.wav A config file has to be fed to a batch script. The \u0026quot;effects_demo\u0026quot; includes sample config files for different GPU architectures. I hava an NVIDIA RTX 4080, so I would customize the \u0026quot;denoiser48k_cfg_ada.txt\u0026quot; config file and run it with the \u0026quot;run_denoiser_48k_ada.bat\u0026quot; batch file. Example config:\n1# Effect. 2# Supported values are: denoiser/dereverb/dereverb_denoiser/aec/superres 3effect dereverb_denoiser 4# Point this to the model file. 5# This indicates 48k model for denoiser effect for ADA supported GPU architecture is picked from models folder 6# Similarly, this path can be modified as per user\u0026#39;s choice of effect and sample rate (8k/16k/48k depending on effect) 7model models\\ada\\dereverb_denoiser_48k.trtpkg 8# Noisy input file 9# 48k Input file is picked from denoiser folder. 10# User can modify below line to pick their own file as input. 11input_wav input_files\\48000.wav 12# Denoised audio data will be saved to this file. 13# Output can be dumped at user specifid location too. In this case, Output will be saved to current folder. 14output_wav 48000.wav 15# Set to 1 for real time mode i.e. audio data will be processed 16# at same speed like that of an audio input device like 17# microphone. Since the denoising is faster that real time, the 18# processing will be equal to audio file duration. 19real_time 0 20# Intensity Ratio 21intensity_ratio 0.5 22# Enable VAD 23enable_vad 1 ","link":"https://trimad.github.io/post/2022-04-20-using-the-nvidia-maxine-audio-effects-sdk-demo/","section":"post","tags":["audio","sound","SDK"],"title":"NVIDIA Maxine Windows Audio Effects SDK"},{"body":"","link":"https://trimad.github.io/tags/sdk/","section":"tags","tags":null,"title":"SDK"},{"body":"","link":"https://trimad.github.io/tags/sound/","section":"tags","tags":null,"title":"sound"},{"body":"yt-dlp yt-dlp is a free and open-source command-line tool for downloading videos and audio from YouTube and other video hosting sites. It is a fork of youtube-dl with additional features and improvements, including better performance and more frequent updates. Unlike youtube-dl, which has faced various legal challenges and takedowns, yt-dlp is actively maintained and regularly updated to ensure compatibility with the latest changes in video hosting sites. GitHub Repository Download the Windows executable Download a YouTube video with default settings:\n1yt-dlp \u0026#34;https://www.youtube.com/watch?v=oHg5SJYRHA0\u0026#34; Extract audio from a video:\n1yt-dlp --extract-audio \u0026#34;https://www.youtube.com/watch?v=oHg5SJYRHA0\u0026#34; Specify audio format and audio quality of extracted audio (between 0 (best) and 10 (worst), default = 5):\n1yt-dlp --extract-audio --audio-format mp3 --audio-quality 0 \u0026#34;https://www.youtube.com/watch?v=oHg5SJYRHA0\u0026#34; Download all playlists of YouTube channel/user keeping each playlist in separate directory:\n1yt-dlp -o \u0026#34;%(uploader)s/%(playlist)s/%(playlist_index)s - %(title)s.%(ext)s\u0026#34; \u0026#34;https://www.youtube.com/user/TheLinuxFoundation/playlists\u0026#34; youtube-dl Youtube-dl is a free, open-source command-line program that allows users to download videos and audio from various websites, including YouTube, Vimeo, and SoundCloud. It is available for Windows, macOS, and Linux operating systems. The program supports a wide range of formats, including MP4, WebM, and MP3, and can be customized with various options and parameters. GitHub Repository Download the Windows executable Download a YouTube video with default settings:\n1youtube-dl \u0026#34;https://www.youtube.com/watch?v=oHg5SJYRHA0\u0026#34; Download a YouTube video with the best available audio quality:\n1youtube-dl -f bestaudio \u0026#34;https://www.youtube.com/watch?v=oHg5SJYRHA0\u0026#34; Download an entire YouTube playlist:\n1youtube-dl --yes-playlist \u0026#34;https://www.youtube.com/playlist?list=PLG49S3nxzAnmpdmX7RoTOyuNJQAb-r-gd\u0026#34; Begin downloading from a playlist at a specific position:\n1youtube-dl --yes-playlist --playlist-start 22 \u0026#34;https://www.youtube.com/watch?v=M5c9HdaQqh0\u0026amp;list=PLG49S3nxzAnmpdmX7RoTOyuNJQAb-r-gd\u0026#34; ","link":"https://trimad.github.io/post/2022-04-16-downloading-youtube-videos/","section":"post","tags":["download","youtube-dl","yt-dlp"],"title":"Download YouTube Videos"},{"body":"","link":"https://trimad.github.io/tags/youtube-dl/","section":"tags","tags":null,"title":"youtube-dl"},{"body":"","link":"https://trimad.github.io/tags/yt-dlp/","section":"tags","tags":null,"title":"yt-dlp"},{"body":"This script uses the Windows command-line tool \u0026quot;netsh\u0026quot; to retrieve information about wireless network profiles that have been previously connected to on the computer. It then parses the information to extract the SSID (name) and password for each profile, and outputs that information to a CSV file named \u0026quot;output.csv\u0026quot;. Finally, the script opens the \u0026quot;output.csv\u0026quot; file.\nThe script uses the \u0026quot;Invoke-Item\u0026quot; command to open the \u0026quot;output.csv\u0026quot; file, which is the PowerShell command equivalent of double-clicking on a file in Windows Explorer. It opens the file in the default application associated with the .csv file type on the system, typically it will be opened in excel or similar spreadsheet software.\n","link":"https://trimad.github.io/post/2022-04-11-dump-wifi-passwords/","section":"post","tags":["netsh","passwords","reports"],"title":"Dump WiFi Passwords"},{"body":"","link":"https://trimad.github.io/tags/reports/","section":"tags","tags":null,"title":"reports"},{"body":"","link":"https://trimad.github.io/categories/batchfile/","section":"categories","tags":null,"title":"Batchfile"},{"body":"Place these 3 files in any directory and run update.vbs to begin recording a Windows session silently.\nGithub Repository update.exe This file is just ffmpeg that's been renamed to be slightly more inconspicuous in Task Manager. update.bat There are two lines to this batch file. The first line deletes \u0026quot;output.mp4\u0026quot; if it already exists in the same directory. The framerate in frames per second of the recording is set here following the \u0026quot;-framerate\u0026quot; flag The amount of time in seconds to record is set here following the \u0026quot;-t\u0026quot; flag output.mp4 will be saved in the same directory after the specified amount of recording time is up. update.vbs This Visual Basic script runs udpate.bat without a visible command prompt. ","link":"https://trimad.github.io/post/2022-02-09-record-desktop-silently/","section":"post","tags":["ffmpeg"],"title":"Record Desktop Silently"},{"body":"","link":"https://trimad.github.io/categories/vbscript/","section":"categories","tags":null,"title":"VBScript"},{"body":"","link":"https://trimad.github.io/categories/ffmpeg/","section":"categories","tags":null,"title":"ffmpeg"},{"body":"ffmpeg is a complete, cross-platform solution to record, convert and stream audio and video.\nffmpeg Download ffmpeg Documentation Audio Processing Convert to 8kHz, single-channel PCM 1ffmpeg -i \u0026#34;input.mp3\u0026#34; -ar 8000 -ac 1 output.wav Convert to 16kHz, single-channel PCM 1ffmpeg -i \u0026#34;input.mp3\u0026#34; -ar 16000 -ac 1 output.wav Convert to 48kHz, single-channel PCM 1ffmpeg -i input.mp3 -ar 48000 -ac 1 output.wav Video Processing Add Music to a Video 1ffmpeg -i video.mp4 -i music.mp3 -codec copy -shortest output.mp4 -i video.mp4 Select ‚Äúvideo.mp4‚Äù as an input file from the same directory. -i music.mp3 Select ‚Äúmusic.mp4‚Äù as an input file from the same directory. -codec copy Specifies that we are not re-encoding anything. -shortest Use this flag if the video length is shorter than the audio length. Otherwise, use no flag at all here. Assemble images into a video 1ffmpeg -framerate 60 -s 2560x1440 -i %04d.png output.mp4 -framerate 60 Set the frame rate to 60FPS. -s 2560x1440 Set the video resolution to 2560x1440 pixels. -i %04d.png This flag assumes there is a folder of .png files in the same directory named in the format 0001.png, 0002.png, etc. It will load all images following this naming convention as inputs to be processed. 1\u0026gt;ffmpeg -start_number 0140 -i %04d.png interpolated-0.mp4 Re-encode Video For YouTube 1ffmpeg -i transition.mp4 -c:v libx264 -preset slow -crf 18 -c:a copy -pix_fmt yuv420p transition.mkv -i transition.mp4 Select \u0026quot;transition.mp4\u0026quot; as the input file. -c:v libx264 set the video codec to H.264 -preset slow A preset is a collection of options that will provide a certain encoding speed to compression ratio. A slower preset will provide better compression (compression is quality per filesize). This means that, for example, if you target a certain file size or constant bit rate, you will achieve better quality with a slower preset. Similarly, for constant quality encoding, you will simply save bitrate by choosing a slower preset. Use the slowest preset that you have patience for. The available presets in descending order of speed are: ultrafast superfast veryfast faster fast medium (default preset) slow slower veryslow -crf 18 Constant Rate Factor (CRF). The range of the CRF scale is 0‚Äì51, where 0 is lossless, 23 is the default, and 51 is worst quality possible. A lower value generally leads to higher quality, and a subjectively sane range is 17‚Äì28. Consider 17 or 18 to be visually lossless or nearly so; it should look the same or nearly the same as the input but it isn't technically lossless. -c:a copy Copy the audio codec from that of the input file to the output file -pix_fmt yuv420p This flag is only needed for your output to work in QuickTime, Windows Media player and other offline media players. These players only support the YUV planar color space with 4:2:0 chroma subsampling for H.264 video. Otherwise, depending on your source, ffmpeg may output to a pixel format that may be incompatible with these players. Video Filters Stack two videos side-by-side 1ffmpeg -i \u0026#34;left.mp4\u0026#34; -i \u0026#34;right.mp4\u0026#34; -filter_complex hstack output.mp4 This command uses the ffmpeg software to combine two video files, \u0026quot;left.mp4\u0026quot; and \u0026quot;right.mp4\u0026quot;, into a single output video file \u0026quot;output.mp4\u0026quot;. The \u0026quot;-i\u0026quot; option specifies the input video files. The \u0026quot;-filter_complex\u0026quot; option applies the \u0026quot;hstack\u0026quot; filter, which horizontally stacks the two input videos side by side to form a single output video.\nVertical scroll and wrap 1ffmpeg -i input.mp4 -vf scroll=vertical=0.001,format=yuv420p output.mp4 This ffmpeg command takes an input video file named \u0026quot;input.mp4\u0026quot; and applies a video filter to it that creates a scrolling effect with a vertical scroll speed of 0.001 units per frame. The output video is then saved as \u0026quot;output.mp4\u0026quot; in the YUV420P format.\nRemove black bars from top and bottom of video 1ffmpeg -i input.mp4 -vf \u0026#34;crop=iw:ih-40:0:20\u0026#34; -c:v libx264 -crf 18 -pix_fmt yuv420p output.mp4 Resize a video's height while maintaining aspect width aspect ratio 1ffmpeg -i input.mp4 -vf \u0026#34;scale=-1:1280\u0026#34; -c:v libx264 -crf 18 -pix_fmt yuv420p output.mp4 Crop a video down the center 1ffmpeg -i input.mp4 -vf \u0026#34;crop=720:ih:((iw-720)/2):0\u0026#34; -c:v libx264 -crf 18 -pix_fmt yuv420p output.mp4 Do the above three in one go 1ffmpeg -i input.mp4 -vf \u0026#34;crop=iw:ih-40:0:20,scale=-1:1280,crop=720:ih:((iw-720)/2):0\u0026#34; -c:v libx264 -crf 18 -pix_fmt yuv420p output.mp4 Screen recording All screens 1ffmpeg -f gdigrab -framerate 30 -t 5 -i desktop -c:v libx264 -preset ultrafast -pix_fmt yuv420p -c:a aac -b:a 128k output.mp4 Just one screen 1ffmpeg -f gdigrab -framerate 30 -t 5 -offset_x 0 -offset_y 0 -video_size 1920x1080 -i desktop -c:v libx264 -preset ultrafast -pix_fmt yuv420p -c:a aac -b:a 128k output.mp4 Animated GIF Create an animated GIF from a video 1ffmpeg -i input.mp4 output.gif Assembled a folder of images into an animated GIF Generate a palette 1ffmpeg -y -i %3d.png -vf palettegen palette.png The command line above is using FFmpeg to process a sequence of PNG images, where each image is named with a number and a 3 digit format, such as \u0026quot;001.png\u0026quot;, \u0026quot;002.png\u0026quot;, etc. In summary, this command is generating a color palette from a sequence of PNG images and saving the palette to the file \u0026quot;palette.png\u0026quot;. This palette can be used to create a GIF animation from the sequence of images. The resulting palette will have a smaller number of colors than the original images, allowing for a smaller file size for the final GIF.\nThe options used in the command are:\n\u0026quot;-y\u0026quot; : Overwrite output files without asking. \u0026quot;-i %3d.png\u0026quot; : The input file is a sequence of PNG images, where the file name format is \u0026quot;%3d\u0026quot; (3 digits) followed by \u0026quot;.png\u0026quot; \u0026quot;-vf palettegen\u0026quot; : This is a video filter that generates a color palette from the input image sequence. \u0026quot;palette.png\u0026quot; : This is the output file name for the generated color palette. In summary, this command is generating a color palette from a sequence of PNG images and saving the palette to the file \u0026quot;palette.png\u0026quot;. This palette can be used to create a GIF animation from the sequence of images. The resulting palette will have a smaller number of colors than the original images, allowing for a smaller file size for the final GIF. Create an animated GIF using the previously generated color palette 1ffmpeg -y -f image2 -framerate 60 -i %3d.png -i palette.png -filter_complex paletteuse file.gif The command line above is using FFmpeg to create a GIF animation from a sequence of PNG images and a previously generated color palette.\nThe options used in the command are:\n\u0026quot;-y\u0026quot; : Overwrite output files without asking. \u0026quot;-f image2\u0026quot; : The input is a sequence of image files \u0026quot;-framerate 60\u0026quot; : The frame rate for the output gif is set to 60 frames per second \u0026quot;-i %3d.png\u0026quot; : The input file is a sequence of PNG images, where the file name format is \u0026quot;%3d\u0026quot; (3 digits) followed by \u0026quot;.png\u0026quot; \u0026quot;-i palette.png\u0026quot; : The input file is the previously generated color palette \u0026quot;-filter_complex paletteuse\u0026quot; : This is a filter that uses the previously generated palette to create the gif animation \u0026quot;file.gif\u0026quot; : This is the output file name for the created gif animation In summary, this command is creating a gif animation from a sequence of PNG images using a previously generated color palette, and saving the animation to the file \u0026quot;file.gif\u0026quot;. The resulting gif animation will have the same frame rate as the input images and a smaller file size due to the use of a limited color palette. ","link":"https://trimad.github.io/post/2022-01-27-ffmpeg/","section":"post","tags":["audio","video"],"title":"ffmpeg"},{"body":"","link":"https://trimad.github.io/tags/active-directory/","section":"tags","tags":null,"title":"active directory"},{"body":"I found myself in a situation where I needed to generate a report to troubleshoot an email issue for a client. Some data could only be retrieved from the ExchangeOnlineManagement module, and other data only from the AzureAD module. This PowerShell script demonstrates one solution of using both modules in tandem with a nested for-loop that compares the UserPrincipalName with every iteration.\n","link":"https://trimad.github.io/post/2021-11-17-combining-powershell-cmdlets/","section":"post","tags":["azure","reports","active directory"],"title":"Combining PowerShell Cmdlets"},{"body":"","link":"https://trimad.github.io/categories/active-directory/","section":"categories","tags":null,"title":"Active Directory"},{"body":"This PowerShell script generates a report showing all groups and group members when run on an on-premises domain controller. The script requires that you import the ActiveDirectory module. The report is in .csv format so the rows may need some manipulation to see all the members if you're opening it in Excel.\n","link":"https://trimad.github.io/post/2021-09-16-active-directory-group-membership/","section":"post","tags":["active directory","domain","reports"],"title":"Active Directory Group Membership"},{"body":"","link":"https://trimad.github.io/tags/calendars/","section":"tags","tags":null,"title":"calendars"},{"body":"","link":"https://trimad.github.io/tags/domain/","section":"tags","tags":null,"title":"domain"},{"body":" 1#If not installed already 2Install-Module ExchangeOnlineManagement 3#Import 4Import-Module ExchangeOnlineManagement 5#Connect 6Connect-ExchangeOnline -UserPrincipalName \u0026lt;UPN\u0026gt; 7 8# Remove AccessRights from a user 9Remove-MailboxFolderPermission -Identity target@company.com:\\Calendar -User user@company.com 10# Grant AccessRights to a user 11Add-MailboxFolderPermission -Identity target@company.com:\\Calendar -User user@company.com -AccessRights Owner 12# See who currently has folder permissions to a user\u0026#39;s calendar 13Get-MailboxFolderPermission -Identity target@company.com:\\Calendar I haven't tested these since 2021:\n1# Connect to Exchage 2Import-Module ExchangeOnlineManagement 3Connect-ExchangeOnline -UserPrincipalName \u0026lt;UPN\u0026gt; 4 5# Get a list of all mailbox aliases 6# Source: https://docs.microsoft.com/en-us/powershell/module/exchange/get-mailbox?view=exchange-ps 7$users = Get-Mailbox | Select -ExpandProperty Alias 8 9# Add AccessRights for a user to all mailboxes 10# Source: https://docs.microsoft.com/en-us/powershell/module/exchange/add-mailboxfolderpermission?view=exchange-ps 11Foreach ($user in $users) {Add-MailboxFolderPermission $user\u0026#34;:\\Calendar\u0026#34; -User \u0026lt;UPN\u0026gt; -AccessRights PublishingEditor} 12 13# Set AccessRights to a user for all mailboxes. You would do this if AccessRights already exist and you need to overwrite them. 14# Source: https://docs.microsoft.com/en-us/powershell/module/exchange/set-mailboxfolderpermission?view=exchange-ps 15Foreach ($user in $users) {Set-MailboxFolderPermission $user\u0026#34;:\\Calendar\u0026#34; -User \u0026lt;UPN\u0026gt; -AccessRights PublishingEditor} 16 17# Get the current access rights this user has for all mailboxes. 18# Source: https://docs.microsoft.com/en-us/powershell/module/exchange/get-mailboxfolderpermission?view=exchange-ps 19Foreach ($user in $users) {Get-MailboxFolderPermission $user\u0026#34;:\\Calendar\u0026#34; -User \u0026lt;UPN\u0026gt;} ","link":"https://trimad.github.io/post/2021-09-16-manage-exchange-online-calendars/","section":"post","tags":["calendars","M365"],"title":"Managing Exchange Calendars"},{"body":"Managing auto-expanding archives via the ExchangeOnlineManagement module is a pain in my ass. This Github Gist is an aggregate of scripts I've written that allow me to administrate this mailbox feature effectively.\n","link":"https://trimad.github.io/post/2021-07-06-manage-auto-expanding-archives/","section":"post","tags":["office","reports"],"title":"Managing Auto-Expanding Archives"},{"body":"","link":"https://trimad.github.io/tags/office/","section":"tags","tags":null,"title":"office"},{"body":"","link":"https://trimad.github.io/tags/k-means/","section":"tags","tags":null,"title":"k-means"},{"body":"k-means clustering is a method of vector quantization, originally from signal processing, that aims to partition n observations into k clusters in which each observation belongs to the cluster with the nearest mean (cluster centers or cluster centroid), serving as a prototype of the cluster. This results in a partitioning of the data space into Voronoi cells.\nGitHub repository: https://github.com/Trimad/k-means-clustering\n","link":"https://trimad.github.io/post/2021-05-18-k-means-clustering/","section":"post","tags":["animation","k-means"],"title":"k-means Clustering"},{"body":"","link":"https://trimad.github.io/categories/reference/","section":"categories","tags":null,"title":"reference"},{"body":"Knowing the URI Scheme is useful because you can jump straight to specific settings menus using ü™ü+R.\nSource","link":"https://trimad.github.io/post/2021-01-01-ms-settings-uri-reference/","section":"post","tags":[],"title":"Windows 10/11 ms-settings URI Scheme Reference"},{"body":"","link":"https://trimad.github.io/tags/appx/","section":"tags","tags":null,"title":"appx"},{"body":"","link":"https://trimad.github.io/categories/appx/","section":"categories","tags":null,"title":"Appx"},{"body":"PowerShell script that reboots a list of computers and emails the status of the machines.\n","link":"https://trimad.github.io/post/2019-08-28-remote-reboot-with-smtp-status/","section":"post","tags":["smtp"],"title":"Remote Reboot With SMTP Status"},{"body":"Microsoft Reference ","link":"https://trimad.github.io/post/2019-08-28-remove-appx-packages/","section":"post","tags":["appx"],"title":"Remove-AppxPackage"},{"body":"","link":"https://trimad.github.io/tags/smtp/","section":"tags","tags":null,"title":"smtp"},{"body":"","link":"https://trimad.github.io/tags/buddhabrot/","section":"tags","tags":null,"title":"buddhabrot"},{"body":"The Buddhabrot fractal is a type of fractal that is generated by plotting the paths of points that escape from the Mandelbrot set. The resulting image resembles a series of intertwined spirals and branches, and is named after the shape it resembles, which is said to resemble the seated figure of Buddha. The Buddhabrot fractal is created by assigning each point in the complex plane a \u0026quot;color\u0026quot; based on how many times it takes for that point to escape from the Mandelbrot set, and then plotting the paths of the points that do escape. This process is repeated millions of times, resulting in a highly detailed and intricate fractal image.\nGitHub Repository ","link":"https://trimad.github.io/post/2019-08-25-buddhabrot/","section":"post","tags":["animation","buddhabrot","fractal"],"title":"Buddhabrot"},{"body":"","link":"https://trimad.github.io/categories/c#/","section":"categories","tags":null,"title":"C#"},{"body":"This Google Apps Script aggregates data submitted by Google Forms, puts it in .xlsx format and sends it in an HTML formatted email.\n","link":"https://trimad.github.io/post/2019-08-25-daily-donation-report/","section":"post","tags":["google forms","gsuite","reports"],"title":"Daily Donation Report"},{"body":"","link":"https://trimad.github.io/categories/fractal/","section":"categories","tags":null,"title":"Fractal"},{"body":"","link":"https://trimad.github.io/categories/google-apps-script/","section":"categories","tags":null,"title":"Google Apps Script"},{"body":"","link":"https://trimad.github.io/tags/google-forms/","section":"tags","tags":null,"title":"google forms"},{"body":"","link":"https://trimad.github.io/tags/gsuite/","section":"tags","tags":null,"title":"gsuite"},{"body":"This script was written to satisfy a niche case where I temporarily needed a PoS (Point of Sale) to automatically login upon startup using AD credentials.\n","link":"https://trimad.github.io/post/2019-08-19-enable-autoadminlogon/","section":"post","tags":["regedit","domain"],"title":"Enable AutoAdminLogon with PowerShell"},{"body":"","link":"https://trimad.github.io/tags/regedit/","section":"tags","tags":null,"title":"regedit"},{"body":"This Processing sketch loads two images and creates an image mask that blends them together. The transparency of the image mask is determined by 4D Open Simplex Noise, which loops perfectly.\n1PImage img1; 2PImage img2; 3PImage imgMask; 4int totalFrames = 60; 5boolean record = true; 6float increment = 0.008; 7 8// Just for non-looping demo 9float zoff = 0; 10 11OpenSimplexNoise noise; 12void setup() { 13 size(512, 512); 14 img1 = loadImage(\u0026#34;textures/texture01.jpg\u0026#34;); 15 img1.resize(width, height); 16 img2 = loadImage(\u0026#34;textures/texture02.jpg\u0026#34;); 17 img2.resize(width, height); 18 imgMask = createImage(width, height, ALPHA); 19 20 noise = new OpenSimplexNoise(); 21} 22 23void draw() { 24 25 float percent = 0; 26 27 if (record) { 28 percent = float(frameCount) / totalFrames; 29 } else { 30 percent = float(frameCount % totalFrames) / totalFrames; 31 } 32 render(percent); 33 image(img2, 0, 0); 34 img1.mask(imgMask); 35 image(img1, 0, 0); 36 37 if (record) { 38 saveFrame(\u0026#34;output/gif-\u0026#34;+nf(frameCount, 3)+\u0026#34;.png\u0026#34;); 39 if (frameCount == totalFrames) { 40 exit(); 41 } 42 } 43} 44 45void render(float percent) { 46 float angle = map(percent, 0, 1, 0, TWO_PI); 47 float uoff = map(sin(angle), -1, 1, 0, 1); 48 float voff = map(cos(angle), -1, 1, 0, 1); 49 float xoff = 0; 50 51 imgMask.loadPixels(); 52 for (int x = 0; x \u0026lt; width; x++) { 53 float yoff = 0; 54 for (int y = 0; y \u0026lt; height; y++) { 55 float n; 56 if (record) { 57 // 4D Open Simplex Noise is very slow! 58 n = (float) noise.eval(xoff, yoff, uoff, voff); 59 } else { 60 // If you aren\u0026#39;t worried about looping run this instead for speed! 61 n = (float) noise.eval(xoff, yoff, zoff); 62 } 63 float bright = map(n, 0, 1, 0, 255); 64 imgMask.pixels[x + y * width] = color(bright); 65 yoff += increment; 66 } 67 xoff += increment; 68 } 69 imgMask.updatePixels(); 70 71 if (!record) { 72 zoff += increment; 73 } 74} GitHub repository for the OpenSimplexNoise class 1/* 2 * OpenSimplex Noise in Java. 3 * by Kurt Spencer 4 * 5 * v1.1 (October 5, 2014) 6 * - Added 2D and 4D implementations. 7 * - Proper gradient sets for all dimensions, from a 8 * dimensionally-generalizable scheme with an actual 9 * rhyme and reason behind it. 10 * - Removed default permutation array in favor of 11 * default seed. 12 * - Changed seed-based constructor to be independent 13 * of any particular randomization library, so results 14 * will be the same when ported to other languages. 15 */ 16 17public class OpenSimplexNoise { 18 19 private static final double STRETCH_CONSTANT_2D = -0.211324865405187; //(1/Math.sqrt(2+1)-1)/2; 20 private static final double SQUISH_CONSTANT_2D = 0.366025403784439; //(Math.sqrt(2+1)-1)/2; 21 private static final double STRETCH_CONSTANT_3D = -1.0 / 6; //(1/Math.sqrt(3+1)-1)/3; 22 private static final double SQUISH_CONSTANT_3D = 1.0 / 3; //(Math.sqrt(3+1)-1)/3; 23 private static final double STRETCH_CONSTANT_4D = -0.138196601125011; //(1/Math.sqrt(4+1)-1)/4; 24 private static final double SQUISH_CONSTANT_4D = 0.309016994374947; //(Math.sqrt(4+1)-1)/4; 25 26 private static final double NORM_CONSTANT_2D = 47; 27 private static final double NORM_CONSTANT_3D = 103; 28 private static final double NORM_CONSTANT_4D = 30; 29 30 private static final long DEFAULT_SEED = 0; 31 32 private short[] perm; 33 private short[] permGradIndex3D; 34 35 public OpenSimplexNoise() { 36 this(DEFAULT_SEED); 37 } 38 39 public OpenSimplexNoise(short[] perm) { 40 this.perm = perm; 41 permGradIndex3D = new short[256]; 42 43 for (int i = 0; i \u0026lt; 256; i++) { 44 //Since 3D has 24 gradients, simple bitmask won\u0026#39;t work, so precompute modulo array. 45 permGradIndex3D[i] = (short)((perm[i] % (gradients3D.length / 3)) * 3); 46 } 47 } 48 49 //Initializes the class using a permutation array generated from a 64-bit seed. 50 //Generates a proper permutation (i.e. doesn\u0026#39;t merely perform N successive pair swaps on a base array) 51 //Uses a simple 64-bit LCG. 52 public OpenSimplexNoise(long seed) { 53 perm = new short[256]; 54 permGradIndex3D = new short[256]; 55 short[] source = new short[256]; 56 for (short i = 0; i \u0026lt; 256; i++) 57 source[i] = i; 58 seed = seed * 6364136223846793005l + 1442695040888963407l; 59 seed = seed * 6364136223846793005l + 1442695040888963407l; 60 seed = seed * 6364136223846793005l + 1442695040888963407l; 61 for (int i = 255; i \u0026gt;= 0; i--) { 62 seed = seed * 6364136223846793005l + 1442695040888963407l; 63 int r = (int)((seed + 31) % (i + 1)); 64 if (r \u0026lt; 0) 65 r += (i + 1); 66 perm[i] = source[r]; 67 permGradIndex3D[i] = (short)((perm[i] % (gradients3D.length / 3)) * 3); 68 source[r] = source[i]; 69 } 70 } 71 72 //2D OpenSimplex Noise. 73 public double eval(double x, double y) { 74 75 //Place input coordinates onto grid. 76 double stretchOffset = (x + y) * STRETCH_CONSTANT_2D; 77 double xs = x + stretchOffset; 78 double ys = y + stretchOffset; 79 80 //Floor to get grid coordinates of rhombus (stretched square) super-cell origin. 81 int xsb = fastFloor(xs); 82 int ysb = fastFloor(ys); 83 84 //Skew out to get actual coordinates of rhombus origin. We\u0026#39;ll need these later. 85 double squishOffset = (xsb + ysb) * SQUISH_CONSTANT_2D; 86 double xb = xsb + squishOffset; 87 double yb = ysb + squishOffset; 88 89 //Compute grid coordinates relative to rhombus origin. 90 double xins = xs - xsb; 91 double yins = ys - ysb; 92 93 //Sum those together to get a value that determines which region we\u0026#39;re in. 94 double inSum = xins + yins; 95 96 //Positions relative to origin point. 97 double dx0 = x - xb; 98 double dy0 = y - yb; 99 100 //We\u0026#39;ll be defining these inside the next block and using them afterwards. 101 double dx_ext, dy_ext; 102 int xsv_ext, ysv_ext; 103 104 double value = 0; 105 106 //Contribution (1,0) 107 double dx1 = dx0 - 1 - SQUISH_CONSTANT_2D; 108 double dy1 = dy0 - 0 - SQUISH_CONSTANT_2D; 109 double attn1 = 2 - dx1 * dx1 - dy1 * dy1; 110 if (attn1 \u0026gt; 0) { 111 attn1 *= attn1; 112 value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, dx1, dy1); 113 } 114 115 //Contribution (0,1) 116 double dx2 = dx0 - 0 - SQUISH_CONSTANT_2D; 117 double dy2 = dy0 - 1 - SQUISH_CONSTANT_2D; 118 double attn2 = 2 - dx2 * dx2 - dy2 * dy2; 119 if (attn2 \u0026gt; 0) { 120 attn2 *= attn2; 121 value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, dx2, dy2); 122 } 123 124 if (inSum \u0026lt;= 1) { //We\u0026#39;re inside the triangle (2-Simplex) at (0,0) 125 double zins = 1 - inSum; 126 if (zins \u0026gt; xins || zins \u0026gt; yins) { //(0,0) is one of the closest two triangular vertices 127 if (xins \u0026gt; yins) { 128 xsv_ext = xsb + 1; 129 ysv_ext = ysb - 1; 130 dx_ext = dx0 - 1; 131 dy_ext = dy0 + 1; 132 } else { 133 xsv_ext = xsb - 1; 134 ysv_ext = ysb + 1; 135 dx_ext = dx0 + 1; 136 dy_ext = dy0 - 1; 137 } 138 } else { //(1,0) and (0,1) are the closest two vertices. 139 xsv_ext = xsb + 1; 140 ysv_ext = ysb + 1; 141 dx_ext = dx0 - 1 - 2 * SQUISH_CONSTANT_2D; 142 dy_ext = dy0 - 1 - 2 * SQUISH_CONSTANT_2D; 143 } 144 } else { //We\u0026#39;re inside the triangle (2-Simplex) at (1,1) 145 double zins = 2 - inSum; 146 if (zins \u0026lt; xins || zins \u0026lt; yins) { //(0,0) is one of the closest two triangular vertices 147 if (xins \u0026gt; yins) { 148 xsv_ext = xsb + 2; 149 ysv_ext = ysb + 0; 150 dx_ext = dx0 - 2 - 2 * SQUISH_CONSTANT_2D; 151 dy_ext = dy0 + 0 - 2 * SQUISH_CONSTANT_2D; 152 } else { 153 xsv_ext = xsb + 0; 154 ysv_ext = ysb + 2; 155 dx_ext = dx0 + 0 - 2 * SQUISH_CONSTANT_2D; 156 dy_ext = dy0 - 2 - 2 * SQUISH_CONSTANT_2D; 157 } 158 } else { //(1,0) and (0,1) are the closest two vertices. 159 dx_ext = dx0; 160 dy_ext = dy0; 161 xsv_ext = xsb; 162 ysv_ext = ysb; 163 } 164 xsb += 1; 165 ysb += 1; 166 dx0 = dx0 - 1 - 2 * SQUISH_CONSTANT_2D; 167 dy0 = dy0 - 1 - 2 * SQUISH_CONSTANT_2D; 168 } 169 170 //Contribution (0,0) or (1,1) 171 double attn0 = 2 - dx0 * dx0 - dy0 * dy0; 172 if (attn0 \u0026gt; 0) { 173 attn0 *= attn0; 174 value += attn0 * attn0 * extrapolate(xsb, ysb, dx0, dy0); 175 } 176 177 //Extra Vertex 178 double attn_ext = 2 - dx_ext * dx_ext - dy_ext * dy_ext; 179 if (attn_ext \u0026gt; 0) { 180 attn_ext *= attn_ext; 181 value += attn_ext * attn_ext * extrapolate(xsv_ext, ysv_ext, dx_ext, dy_ext); 182 } 183 184 return value / NORM_CONSTANT_2D; 185 } 186 187 //3D OpenSimplex Noise. 188 public double eval(double x, double y, double z) { 189 190 //Place input coordinates on simplectic honeycomb. 191 double stretchOffset = (x + y + z) * STRETCH_CONSTANT_3D; 192 double xs = x + stretchOffset; 193 double ys = y + stretchOffset; 194 double zs = z + stretchOffset; 195 196 //Floor to get simplectic honeycomb coordinates of rhombohedron (stretched cube) super-cell origin. 197 int xsb = fastFloor(xs); 198 int ysb = fastFloor(ys); 199 int zsb = fastFloor(zs); 200 201 //Skew out to get actual coordinates of rhombohedron origin. We\u0026#39;ll need these later. 202 double squishOffset = (xsb + ysb + zsb) * SQUISH_CONSTANT_3D; 203 double xb = xsb + squishOffset; 204 double yb = ysb + squishOffset; 205 double zb = zsb + squishOffset; 206 207 //Compute simplectic honeycomb coordinates relative to rhombohedral origin. 208 double xins = xs - xsb; 209 double yins = ys - ysb; 210 double zins = zs - zsb; 211 212 //Sum those together to get a value that determines which region we\u0026#39;re in. 213 double inSum = xins + yins + zins; 214 215 //Positions relative to origin point. 216 double dx0 = x - xb; 217 double dy0 = y - yb; 218 double dz0 = z - zb; 219 220 //We\u0026#39;ll be defining these inside the next block and using them afterwards. 221 double dx_ext0, dy_ext0, dz_ext0; 222 double dx_ext1, dy_ext1, dz_ext1; 223 int xsv_ext0, ysv_ext0, zsv_ext0; 224 int xsv_ext1, ysv_ext1, zsv_ext1; 225 226 double value = 0; 227 if (inSum \u0026lt;= 1) { //We\u0026#39;re inside the tetrahedron (3-Simplex) at (0,0,0) 228 229 //Determine which two of (0,0,1), (0,1,0), (1,0,0) are closest. 230 byte aPoint = 0x01; 231 double aScore = xins; 232 byte bPoint = 0x02; 233 double bScore = yins; 234 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; zins \u0026gt; bScore) { 235 bScore = zins; 236 bPoint = 0x04; 237 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; zins \u0026gt; aScore) { 238 aScore = zins; 239 aPoint = 0x04; 240 } 241 242 //Now we determine the two lattice points not part of the tetrahedron that may contribute. 243 //This depends on the closest two tetrahedral vertices, including (0,0,0) 244 double wins = 1 - inSum; 245 if (wins \u0026gt; aScore || wins \u0026gt; bScore) { //(0,0,0) is one of the closest two tetrahedral vertices. 246 byte c = (bScore \u0026gt; aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b. 247 248 if ((c \u0026amp; 0x01) == 0) { 249 xsv_ext0 = xsb - 1; 250 xsv_ext1 = xsb; 251 dx_ext0 = dx0 + 1; 252 dx_ext1 = dx0; 253 } else { 254 xsv_ext0 = xsv_ext1 = xsb + 1; 255 dx_ext0 = dx_ext1 = dx0 - 1; 256 } 257 258 if ((c \u0026amp; 0x02) == 0) { 259 ysv_ext0 = ysv_ext1 = ysb; 260 dy_ext0 = dy_ext1 = dy0; 261 if ((c \u0026amp; 0x01) == 0) { 262 ysv_ext1 -= 1; 263 dy_ext1 += 1; 264 } else { 265 ysv_ext0 -= 1; 266 dy_ext0 += 1; 267 } 268 } else { 269 ysv_ext0 = ysv_ext1 = ysb + 1; 270 dy_ext0 = dy_ext1 = dy0 - 1; 271 } 272 273 if ((c \u0026amp; 0x04) == 0) { 274 zsv_ext0 = zsb; 275 zsv_ext1 = zsb - 1; 276 dz_ext0 = dz0; 277 dz_ext1 = dz0 + 1; 278 } else { 279 zsv_ext0 = zsv_ext1 = zsb + 1; 280 dz_ext0 = dz_ext1 = dz0 - 1; 281 } 282 } else { //(0,0,0) is not one of the closest two tetrahedral vertices. 283 byte c = (byte)(aPoint | bPoint); //Our two extra vertices are determined by the closest two. 284 285 if ((c \u0026amp; 0x01) == 0) { 286 xsv_ext0 = xsb; 287 xsv_ext1 = xsb - 1; 288 dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_3D; 289 dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D; 290 } else { 291 xsv_ext0 = xsv_ext1 = xsb + 1; 292 dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D; 293 dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D; 294 } 295 296 if ((c \u0026amp; 0x02) == 0) { 297 ysv_ext0 = ysb; 298 ysv_ext1 = ysb - 1; 299 dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_3D; 300 dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D; 301 } else { 302 ysv_ext0 = ysv_ext1 = ysb + 1; 303 dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D; 304 dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D; 305 } 306 307 if ((c \u0026amp; 0x04) == 0) { 308 zsv_ext0 = zsb; 309 zsv_ext1 = zsb - 1; 310 dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_3D; 311 dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D; 312 } else { 313 zsv_ext0 = zsv_ext1 = zsb + 1; 314 dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D; 315 dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D; 316 } 317 } 318 319 //Contribution (0,0,0) 320 double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0; 321 if (attn0 \u0026gt; 0) { 322 attn0 *= attn0; 323 value += attn0 * attn0 * extrapolate(xsb + 0, ysb + 0, zsb + 0, dx0, dy0, dz0); 324 } 325 326 //Contribution (1,0,0) 327 double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D; 328 double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D; 329 double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D; 330 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1; 331 if (attn1 \u0026gt; 0) { 332 attn1 *= attn1; 333 value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, dx1, dy1, dz1); 334 } 335 336 //Contribution (0,1,0) 337 double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D; 338 double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D; 339 double dz2 = dz1; 340 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2; 341 if (attn2 \u0026gt; 0) { 342 attn2 *= attn2; 343 value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, dx2, dy2, dz2); 344 } 345 346 //Contribution (0,0,1) 347 double dx3 = dx2; 348 double dy3 = dy1; 349 double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D; 350 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3; 351 if (attn3 \u0026gt; 0) { 352 attn3 *= attn3; 353 value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, dx3, dy3, dz3); 354 } 355 } else if (inSum \u0026gt;= 2) { //We\u0026#39;re inside the tetrahedron (3-Simplex) at (1,1,1) 356 357 //Determine which two tetrahedral vertices are the closest, out of (1,1,0), (1,0,1), (0,1,1) but not (1,1,1). 358 byte aPoint = 0x06; 359 double aScore = xins; 360 byte bPoint = 0x05; 361 double bScore = yins; 362 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; zins \u0026lt; bScore) { 363 bScore = zins; 364 bPoint = 0x03; 365 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; zins \u0026lt; aScore) { 366 aScore = zins; 367 aPoint = 0x03; 368 } 369 370 //Now we determine the two lattice points not part of the tetrahedron that may contribute. 371 //This depends on the closest two tetrahedral vertices, including (1,1,1) 372 double wins = 3 - inSum; 373 if (wins \u0026lt; aScore || wins \u0026lt; bScore) { //(1,1,1) is one of the closest two tetrahedral vertices. 374 byte c = (bScore \u0026lt; aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b. 375 376 if ((c \u0026amp; 0x01) != 0) { 377 xsv_ext0 = xsb + 2; 378 xsv_ext1 = xsb + 1; 379 dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_3D; 380 dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D; 381 } else { 382 xsv_ext0 = xsv_ext1 = xsb; 383 dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_3D; 384 } 385 386 if ((c \u0026amp; 0x02) != 0) { 387 ysv_ext0 = ysv_ext1 = ysb + 1; 388 dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D; 389 if ((c \u0026amp; 0x01) != 0) { 390 ysv_ext1 += 1; 391 dy_ext1 -= 1; 392 } else { 393 ysv_ext0 += 1; 394 dy_ext0 -= 1; 395 } 396 } else { 397 ysv_ext0 = ysv_ext1 = ysb; 398 dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_3D; 399 } 400 401 if ((c \u0026amp; 0x04) != 0) { 402 zsv_ext0 = zsb + 1; 403 zsv_ext1 = zsb + 2; 404 dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D; 405 dz_ext1 = dz0 - 2 - 3 * SQUISH_CONSTANT_3D; 406 } else { 407 zsv_ext0 = zsv_ext1 = zsb; 408 dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_3D; 409 } 410 } else { //(1,1,1) is not one of the closest two tetrahedral vertices. 411 byte c = (byte)(aPoint \u0026amp; bPoint); //Our two extra vertices are determined by the closest two. 412 413 if ((c \u0026amp; 0x01) != 0) { 414 xsv_ext0 = xsb + 1; 415 xsv_ext1 = xsb + 2; 416 dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D; 417 dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D; 418 } else { 419 xsv_ext0 = xsv_ext1 = xsb; 420 dx_ext0 = dx0 - SQUISH_CONSTANT_3D; 421 dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D; 422 } 423 424 if ((c \u0026amp; 0x02) != 0) { 425 ysv_ext0 = ysb + 1; 426 ysv_ext1 = ysb + 2; 427 dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D; 428 dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D; 429 } else { 430 ysv_ext0 = ysv_ext1 = ysb; 431 dy_ext0 = dy0 - SQUISH_CONSTANT_3D; 432 dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D; 433 } 434 435 if ((c \u0026amp; 0x04) != 0) { 436 zsv_ext0 = zsb + 1; 437 zsv_ext1 = zsb + 2; 438 dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D; 439 dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D; 440 } else { 441 zsv_ext0 = zsv_ext1 = zsb; 442 dz_ext0 = dz0 - SQUISH_CONSTANT_3D; 443 dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D; 444 } 445 } 446 447 //Contribution (1,1,0) 448 double dx3 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D; 449 double dy3 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D; 450 double dz3 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D; 451 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3; 452 if (attn3 \u0026gt; 0) { 453 attn3 *= attn3; 454 value += attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, dx3, dy3, dz3); 455 } 456 457 //Contribution (1,0,1) 458 double dx2 = dx3; 459 double dy2 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D; 460 double dz2 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D; 461 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2; 462 if (attn2 \u0026gt; 0) { 463 attn2 *= attn2; 464 value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, dx2, dy2, dz2); 465 } 466 467 //Contribution (0,1,1) 468 double dx1 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D; 469 double dy1 = dy3; 470 double dz1 = dz2; 471 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1; 472 if (attn1 \u0026gt; 0) { 473 attn1 *= attn1; 474 value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, dx1, dy1, dz1); 475 } 476 477 //Contribution (1,1,1) 478 dx0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D; 479 dy0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D; 480 dz0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D; 481 double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0; 482 if (attn0 \u0026gt; 0) { 483 attn0 *= attn0; 484 value += attn0 * attn0 * extrapolate(xsb + 1, ysb + 1, zsb + 1, dx0, dy0, dz0); 485 } 486 } else { //We\u0026#39;re inside the octahedron (Rectified 3-Simplex) in between. 487 double aScore; 488 byte aPoint; 489 boolean aIsFurtherSide; 490 double bScore; 491 byte bPoint; 492 boolean bIsFurtherSide; 493 494 //Decide between point (0,0,1) and (1,1,0) as closest 495 double p1 = xins + yins; 496 if (p1 \u0026gt; 1) { 497 aScore = p1 - 1; 498 aPoint = 0x03; 499 aIsFurtherSide = true; 500 } else { 501 aScore = 1 - p1; 502 aPoint = 0x04; 503 aIsFurtherSide = false; 504 } 505 506 //Decide between point (0,1,0) and (1,0,1) as closest 507 double p2 = xins + zins; 508 if (p2 \u0026gt; 1) { 509 bScore = p2 - 1; 510 bPoint = 0x05; 511 bIsFurtherSide = true; 512 } else { 513 bScore = 1 - p2; 514 bPoint = 0x02; 515 bIsFurtherSide = false; 516 } 517 518 //The closest out of the two (1,0,0) and (0,1,1) will replace the furthest out of the two decided above, if closer. 519 double p3 = yins + zins; 520 if (p3 \u0026gt; 1) { 521 double score = p3 - 1; 522 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; aScore \u0026lt; score) { 523 aScore = score; 524 aPoint = 0x06; 525 aIsFurtherSide = true; 526 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; bScore \u0026lt; score) { 527 bScore = score; 528 bPoint = 0x06; 529 bIsFurtherSide = true; 530 } 531 } else { 532 double score = 1 - p3; 533 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; aScore \u0026lt; score) { 534 aScore = score; 535 aPoint = 0x01; 536 aIsFurtherSide = false; 537 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; bScore \u0026lt; score) { 538 bScore = score; 539 bPoint = 0x01; 540 bIsFurtherSide = false; 541 } 542 } 543 544 //Where each of the two closest points are determines how the extra two vertices are calculated. 545 if (aIsFurtherSide == bIsFurtherSide) { 546 if (aIsFurtherSide) { //Both closest points on (1,1,1) side 547 548 //One of the two extra points is (1,1,1) 549 dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_3D; 550 dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_3D; 551 dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_3D; 552 xsv_ext0 = xsb + 1; 553 ysv_ext0 = ysb + 1; 554 zsv_ext0 = zsb + 1; 555 556 //Other extra point is based on the shared axis. 557 byte c = (byte)(aPoint \u0026amp; bPoint); 558 if ((c \u0026amp; 0x01) != 0) { 559 dx_ext1 = dx0 - 2 - 2 * SQUISH_CONSTANT_3D; 560 dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D; 561 dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D; 562 xsv_ext1 = xsb + 2; 563 ysv_ext1 = ysb; 564 zsv_ext1 = zsb; 565 } else if ((c \u0026amp; 0x02) != 0) { 566 dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D; 567 dy_ext1 = dy0 - 2 - 2 * SQUISH_CONSTANT_3D; 568 dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D; 569 xsv_ext1 = xsb; 570 ysv_ext1 = ysb + 2; 571 zsv_ext1 = zsb; 572 } else { 573 dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D; 574 dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D; 575 dz_ext1 = dz0 - 2 - 2 * SQUISH_CONSTANT_3D; 576 xsv_ext1 = xsb; 577 ysv_ext1 = ysb; 578 zsv_ext1 = zsb + 2; 579 } 580 } else {//Both closest points on (0,0,0) side 581 582 //One of the two extra points is (0,0,0) 583 dx_ext0 = dx0; 584 dy_ext0 = dy0; 585 dz_ext0 = dz0; 586 xsv_ext0 = xsb; 587 ysv_ext0 = ysb; 588 zsv_ext0 = zsb; 589 590 //Other extra point is based on the omitted axis. 591 byte c = (byte)(aPoint | bPoint); 592 if ((c \u0026amp; 0x01) == 0) { 593 dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_3D; 594 dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D; 595 dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D; 596 xsv_ext1 = xsb - 1; 597 ysv_ext1 = ysb + 1; 598 zsv_ext1 = zsb + 1; 599 } else if ((c \u0026amp; 0x02) == 0) { 600 dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D; 601 dy_ext1 = dy0 + 1 - SQUISH_CONSTANT_3D; 602 dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_3D; 603 xsv_ext1 = xsb + 1; 604 ysv_ext1 = ysb - 1; 605 zsv_ext1 = zsb + 1; 606 } else { 607 dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_3D; 608 dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_3D; 609 dz_ext1 = dz0 + 1 - SQUISH_CONSTANT_3D; 610 xsv_ext1 = xsb + 1; 611 ysv_ext1 = ysb + 1; 612 zsv_ext1 = zsb - 1; 613 } 614 } 615 } else { //One point on (0,0,0) side, one point on (1,1,1) side 616 byte c1, c2; 617 if (aIsFurtherSide) { 618 c1 = aPoint; 619 c2 = bPoint; 620 } else { 621 c1 = bPoint; 622 c2 = aPoint; 623 } 624 625 //One contribution is a permutation of (1,1,-1) 626 if ((c1 \u0026amp; 0x01) == 0) { 627 dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_3D; 628 dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D; 629 dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D; 630 xsv_ext0 = xsb - 1; 631 ysv_ext0 = ysb + 1; 632 zsv_ext0 = zsb + 1; 633 } else if ((c1 \u0026amp; 0x02) == 0) { 634 dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D; 635 dy_ext0 = dy0 + 1 - SQUISH_CONSTANT_3D; 636 dz_ext0 = dz0 - 1 - SQUISH_CONSTANT_3D; 637 xsv_ext0 = xsb + 1; 638 ysv_ext0 = ysb - 1; 639 zsv_ext0 = zsb + 1; 640 } else { 641 dx_ext0 = dx0 - 1 - SQUISH_CONSTANT_3D; 642 dy_ext0 = dy0 - 1 - SQUISH_CONSTANT_3D; 643 dz_ext0 = dz0 + 1 - SQUISH_CONSTANT_3D; 644 xsv_ext0 = xsb + 1; 645 ysv_ext0 = ysb + 1; 646 zsv_ext0 = zsb - 1; 647 } 648 649 //One contribution is a permutation of (0,0,2) 650 dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_3D; 651 dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_3D; 652 dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_3D; 653 xsv_ext1 = xsb; 654 ysv_ext1 = ysb; 655 zsv_ext1 = zsb; 656 if ((c2 \u0026amp; 0x01) != 0) { 657 dx_ext1 -= 2; 658 xsv_ext1 += 2; 659 } else if ((c2 \u0026amp; 0x02) != 0) { 660 dy_ext1 -= 2; 661 ysv_ext1 += 2; 662 } else { 663 dz_ext1 -= 2; 664 zsv_ext1 += 2; 665 } 666 } 667 668 //Contribution (1,0,0) 669 double dx1 = dx0 - 1 - SQUISH_CONSTANT_3D; 670 double dy1 = dy0 - 0 - SQUISH_CONSTANT_3D; 671 double dz1 = dz0 - 0 - SQUISH_CONSTANT_3D; 672 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1; 673 if (attn1 \u0026gt; 0) { 674 attn1 *= attn1; 675 value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, dx1, dy1, dz1); 676 } 677 678 //Contribution (0,1,0) 679 double dx2 = dx0 - 0 - SQUISH_CONSTANT_3D; 680 double dy2 = dy0 - 1 - SQUISH_CONSTANT_3D; 681 double dz2 = dz1; 682 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2; 683 if (attn2 \u0026gt; 0) { 684 attn2 *= attn2; 685 value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, dx2, dy2, dz2); 686 } 687 688 //Contribution (0,0,1) 689 double dx3 = dx2; 690 double dy3 = dy1; 691 double dz3 = dz0 - 1 - SQUISH_CONSTANT_3D; 692 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3; 693 if (attn3 \u0026gt; 0) { 694 attn3 *= attn3; 695 value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, dx3, dy3, dz3); 696 } 697 698 //Contribution (1,1,0) 699 double dx4 = dx0 - 1 - 2 * SQUISH_CONSTANT_3D; 700 double dy4 = dy0 - 1 - 2 * SQUISH_CONSTANT_3D; 701 double dz4 = dz0 - 0 - 2 * SQUISH_CONSTANT_3D; 702 double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4; 703 if (attn4 \u0026gt; 0) { 704 attn4 *= attn4; 705 value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 0, dx4, dy4, dz4); 706 } 707 708 //Contribution (1,0,1) 709 double dx5 = dx4; 710 double dy5 = dy0 - 0 - 2 * SQUISH_CONSTANT_3D; 711 double dz5 = dz0 - 1 - 2 * SQUISH_CONSTANT_3D; 712 double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5; 713 if (attn5 \u0026gt; 0) { 714 attn5 *= attn5; 715 value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 0, zsb + 1, dx5, dy5, dz5); 716 } 717 718 //Contribution (0,1,1) 719 double dx6 = dx0 - 0 - 2 * SQUISH_CONSTANT_3D; 720 double dy6 = dy4; 721 double dz6 = dz5; 722 double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6; 723 if (attn6 \u0026gt; 0) { 724 attn6 *= attn6; 725 value += attn6 * attn6 * extrapolate(xsb + 0, ysb + 1, zsb + 1, dx6, dy6, dz6); 726 } 727 } 728 729 //First extra vertex 730 double attn_ext0 = 2 - dx_ext0 * dx_ext0 - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0; 731 if (attn_ext0 \u0026gt; 0) 732 { 733 attn_ext0 *= attn_ext0; 734 value += attn_ext0 * attn_ext0 * extrapolate(xsv_ext0, ysv_ext0, zsv_ext0, dx_ext0, dy_ext0, dz_ext0); 735 } 736 737 //Second extra vertex 738 double attn_ext1 = 2 - dx_ext1 * dx_ext1 - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1; 739 if (attn_ext1 \u0026gt; 0) 740 { 741 attn_ext1 *= attn_ext1; 742 value += attn_ext1 * attn_ext1 * extrapolate(xsv_ext1, ysv_ext1, zsv_ext1, dx_ext1, dy_ext1, dz_ext1); 743 } 744 745 return value / NORM_CONSTANT_3D; 746 } 747 748 //4D OpenSimplex Noise. 749 public double eval(double x, double y, double z, double w) { 750 751 //Place input coordinates on simplectic honeycomb. 752 double stretchOffset = (x + y + z + w) * STRETCH_CONSTANT_4D; 753 double xs = x + stretchOffset; 754 double ys = y + stretchOffset; 755 double zs = z + stretchOffset; 756 double ws = w + stretchOffset; 757 758 //Floor to get simplectic honeycomb coordinates of rhombo-hypercube super-cell origin. 759 int xsb = fastFloor(xs); 760 int ysb = fastFloor(ys); 761 int zsb = fastFloor(zs); 762 int wsb = fastFloor(ws); 763 764 //Skew out to get actual coordinates of stretched rhombo-hypercube origin. We\u0026#39;ll need these later. 765 double squishOffset = (xsb + ysb + zsb + wsb) * SQUISH_CONSTANT_4D; 766 double xb = xsb + squishOffset; 767 double yb = ysb + squishOffset; 768 double zb = zsb + squishOffset; 769 double wb = wsb + squishOffset; 770 771 //Compute simplectic honeycomb coordinates relative to rhombo-hypercube origin. 772 double xins = xs - xsb; 773 double yins = ys - ysb; 774 double zins = zs - zsb; 775 double wins = ws - wsb; 776 777 //Sum those together to get a value that determines which region we\u0026#39;re in. 778 double inSum = xins + yins + zins + wins; 779 780 //Positions relative to origin point. 781 double dx0 = x - xb; 782 double dy0 = y - yb; 783 double dz0 = z - zb; 784 double dw0 = w - wb; 785 786 //We\u0026#39;ll be defining these inside the next block and using them afterwards. 787 double dx_ext0, dy_ext0, dz_ext0, dw_ext0; 788 double dx_ext1, dy_ext1, dz_ext1, dw_ext1; 789 double dx_ext2, dy_ext2, dz_ext2, dw_ext2; 790 int xsv_ext0, ysv_ext0, zsv_ext0, wsv_ext0; 791 int xsv_ext1, ysv_ext1, zsv_ext1, wsv_ext1; 792 int xsv_ext2, ysv_ext2, zsv_ext2, wsv_ext2; 793 794 double value = 0; 795 if (inSum \u0026lt;= 1) { //We\u0026#39;re inside the pentachoron (4-Simplex) at (0,0,0,0) 796 797 //Determine which two of (0,0,0,1), (0,0,1,0), (0,1,0,0), (1,0,0,0) are closest. 798 byte aPoint = 0x01; 799 double aScore = xins; 800 byte bPoint = 0x02; 801 double bScore = yins; 802 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; zins \u0026gt; bScore) { 803 bScore = zins; 804 bPoint = 0x04; 805 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; zins \u0026gt; aScore) { 806 aScore = zins; 807 aPoint = 0x04; 808 } 809 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; wins \u0026gt; bScore) { 810 bScore = wins; 811 bPoint = 0x08; 812 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; wins \u0026gt; aScore) { 813 aScore = wins; 814 aPoint = 0x08; 815 } 816 817 //Now we determine the three lattice points not part of the pentachoron that may contribute. 818 //This depends on the closest two pentachoron vertices, including (0,0,0,0) 819 double uins = 1 - inSum; 820 if (uins \u0026gt; aScore || uins \u0026gt; bScore) { //(0,0,0,0) is one of the closest two pentachoron vertices. 821 byte c = (bScore \u0026gt; aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b. 822 if ((c \u0026amp; 0x01) == 0) { 823 xsv_ext0 = xsb - 1; 824 xsv_ext1 = xsv_ext2 = xsb; 825 dx_ext0 = dx0 + 1; 826 dx_ext1 = dx_ext2 = dx0; 827 } else { 828 xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb + 1; 829 dx_ext0 = dx_ext1 = dx_ext2 = dx0 - 1; 830 } 831 832 if ((c \u0026amp; 0x02) == 0) { 833 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb; 834 dy_ext0 = dy_ext1 = dy_ext2 = dy0; 835 if ((c \u0026amp; 0x01) == 0x01) { 836 ysv_ext0 -= 1; 837 dy_ext0 += 1; 838 } else { 839 ysv_ext1 -= 1; 840 dy_ext1 += 1; 841 } 842 } else { 843 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1; 844 dy_ext0 = dy_ext1 = dy_ext2 = dy0 - 1; 845 } 846 847 if ((c \u0026amp; 0x04) == 0) { 848 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb; 849 dz_ext0 = dz_ext1 = dz_ext2 = dz0; 850 if ((c \u0026amp; 0x03) != 0) { 851 if ((c \u0026amp; 0x03) == 0x03) { 852 zsv_ext0 -= 1; 853 dz_ext0 += 1; 854 } else { 855 zsv_ext1 -= 1; 856 dz_ext1 += 1; 857 } 858 } else { 859 zsv_ext2 -= 1; 860 dz_ext2 += 1; 861 } 862 } else { 863 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1; 864 dz_ext0 = dz_ext1 = dz_ext2 = dz0 - 1; 865 } 866 867 if ((c \u0026amp; 0x08) == 0) { 868 wsv_ext0 = wsv_ext1 = wsb; 869 wsv_ext2 = wsb - 1; 870 dw_ext0 = dw_ext1 = dw0; 871 dw_ext2 = dw0 + 1; 872 } else { 873 wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb + 1; 874 dw_ext0 = dw_ext1 = dw_ext2 = dw0 - 1; 875 } 876 } else { //(0,0,0,0) is not one of the closest two pentachoron vertices. 877 byte c = (byte)(aPoint | bPoint); //Our three extra vertices are determined by the closest two. 878 879 if ((c \u0026amp; 0x01) == 0) { 880 xsv_ext0 = xsv_ext2 = xsb; 881 xsv_ext1 = xsb - 1; 882 dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_4D; 883 dx_ext1 = dx0 + 1 - SQUISH_CONSTANT_4D; 884 dx_ext2 = dx0 - SQUISH_CONSTANT_4D; 885 } else { 886 xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb + 1; 887 dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 888 dx_ext1 = dx_ext2 = dx0 - 1 - SQUISH_CONSTANT_4D; 889 } 890 891 if ((c \u0026amp; 0x02) == 0) { 892 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb; 893 dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_4D; 894 dy_ext1 = dy_ext2 = dy0 - SQUISH_CONSTANT_4D; 895 if ((c \u0026amp; 0x01) == 0x01) { 896 ysv_ext1 -= 1; 897 dy_ext1 += 1; 898 } else { 899 ysv_ext2 -= 1; 900 dy_ext2 += 1; 901 } 902 } else { 903 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1; 904 dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 905 dy_ext1 = dy_ext2 = dy0 - 1 - SQUISH_CONSTANT_4D; 906 } 907 908 if ((c \u0026amp; 0x04) == 0) { 909 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb; 910 dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_4D; 911 dz_ext1 = dz_ext2 = dz0 - SQUISH_CONSTANT_4D; 912 if ((c \u0026amp; 0x03) == 0x03) { 913 zsv_ext1 -= 1; 914 dz_ext1 += 1; 915 } else { 916 zsv_ext2 -= 1; 917 dz_ext2 += 1; 918 } 919 } else { 920 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1; 921 dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 922 dz_ext1 = dz_ext2 = dz0 - 1 - SQUISH_CONSTANT_4D; 923 } 924 925 if ((c \u0026amp; 0x08) == 0) { 926 wsv_ext0 = wsv_ext1 = wsb; 927 wsv_ext2 = wsb - 1; 928 dw_ext0 = dw0 - 2 * SQUISH_CONSTANT_4D; 929 dw_ext1 = dw0 - SQUISH_CONSTANT_4D; 930 dw_ext2 = dw0 + 1 - SQUISH_CONSTANT_4D; 931 } else { 932 wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb + 1; 933 dw_ext0 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 934 dw_ext1 = dw_ext2 = dw0 - 1 - SQUISH_CONSTANT_4D; 935 } 936 } 937 938 //Contribution (0,0,0,0) 939 double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0 - dw0 * dw0; 940 if (attn0 \u0026gt; 0) { 941 attn0 *= attn0; 942 value += attn0 * attn0 * extrapolate(xsb + 0, ysb + 0, zsb + 0, wsb + 0, dx0, dy0, dz0, dw0); 943 } 944 945 //Contribution (1,0,0,0) 946 double dx1 = dx0 - 1 - SQUISH_CONSTANT_4D; 947 double dy1 = dy0 - 0 - SQUISH_CONSTANT_4D; 948 double dz1 = dz0 - 0 - SQUISH_CONSTANT_4D; 949 double dw1 = dw0 - 0 - SQUISH_CONSTANT_4D; 950 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1; 951 if (attn1 \u0026gt; 0) { 952 attn1 *= attn1; 953 value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 0, dx1, dy1, dz1, dw1); 954 } 955 956 //Contribution (0,1,0,0) 957 double dx2 = dx0 - 0 - SQUISH_CONSTANT_4D; 958 double dy2 = dy0 - 1 - SQUISH_CONSTANT_4D; 959 double dz2 = dz1; 960 double dw2 = dw1; 961 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2; 962 if (attn2 \u0026gt; 0) { 963 attn2 *= attn2; 964 value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 0, dx2, dy2, dz2, dw2); 965 } 966 967 //Contribution (0,0,1,0) 968 double dx3 = dx2; 969 double dy3 = dy1; 970 double dz3 = dz0 - 1 - SQUISH_CONSTANT_4D; 971 double dw3 = dw1; 972 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3; 973 if (attn3 \u0026gt; 0) { 974 attn3 *= attn3; 975 value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 0, dx3, dy3, dz3, dw3); 976 } 977 978 //Contribution (0,0,0,1) 979 double dx4 = dx2; 980 double dy4 = dy1; 981 double dz4 = dz1; 982 double dw4 = dw0 - 1 - SQUISH_CONSTANT_4D; 983 double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4; 984 if (attn4 \u0026gt; 0) { 985 attn4 *= attn4; 986 value += attn4 * attn4 * extrapolate(xsb + 0, ysb + 0, zsb + 0, wsb + 1, dx4, dy4, dz4, dw4); 987 } 988 } else if (inSum \u0026gt;= 3) { //We\u0026#39;re inside the pentachoron (4-Simplex) at (1,1,1,1) 989 //Determine which two of (1,1,1,0), (1,1,0,1), (1,0,1,1), (0,1,1,1) are closest. 990 byte aPoint = 0x0E; 991 double aScore = xins; 992 byte bPoint = 0x0D; 993 double bScore = yins; 994 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; zins \u0026lt; bScore) { 995 bScore = zins; 996 bPoint = 0x0B; 997 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; zins \u0026lt; aScore) { 998 aScore = zins; 999 aPoint = 0x0B; 1000 } 1001 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; wins \u0026lt; bScore) { 1002 bScore = wins; 1003 bPoint = 0x07; 1004 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; wins \u0026lt; aScore) { 1005 aScore = wins; 1006 aPoint = 0x07; 1007 } 1008 1009 //Now we determine the three lattice points not part of the pentachoron that may contribute. 1010 //This depends on the closest two pentachoron vertices, including (0,0,0,0) 1011 double uins = 4 - inSum; 1012 if (uins \u0026lt; aScore || uins \u0026lt; bScore) { //(1,1,1,1) is one of the closest two pentachoron vertices. 1013 byte c = (bScore \u0026lt; aScore ? bPoint : aPoint); //Our other closest vertex is the closest out of a and b. 1014 1015 if ((c \u0026amp; 0x01) != 0) { 1016 xsv_ext0 = xsb + 2; 1017 xsv_ext1 = xsv_ext2 = xsb + 1; 1018 dx_ext0 = dx0 - 2 - 4 * SQUISH_CONSTANT_4D; 1019 dx_ext1 = dx_ext2 = dx0 - 1 - 4 * SQUISH_CONSTANT_4D; 1020 } else { 1021 xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb; 1022 dx_ext0 = dx_ext1 = dx_ext2 = dx0 - 4 * SQUISH_CONSTANT_4D; 1023 } 1024 1025 if ((c \u0026amp; 0x02) != 0) { 1026 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1; 1027 dy_ext0 = dy_ext1 = dy_ext2 = dy0 - 1 - 4 * SQUISH_CONSTANT_4D; 1028 if ((c \u0026amp; 0x01) != 0) { 1029 ysv_ext1 += 1; 1030 dy_ext1 -= 1; 1031 } else { 1032 ysv_ext0 += 1; 1033 dy_ext0 -= 1; 1034 } 1035 } else { 1036 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb; 1037 dy_ext0 = dy_ext1 = dy_ext2 = dy0 - 4 * SQUISH_CONSTANT_4D; 1038 } 1039 1040 if ((c \u0026amp; 0x04) != 0) { 1041 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1; 1042 dz_ext0 = dz_ext1 = dz_ext2 = dz0 - 1 - 4 * SQUISH_CONSTANT_4D; 1043 if ((c \u0026amp; 0x03) != 0x03) { 1044 if ((c \u0026amp; 0x03) == 0) { 1045 zsv_ext0 += 1; 1046 dz_ext0 -= 1; 1047 } else { 1048 zsv_ext1 += 1; 1049 dz_ext1 -= 1; 1050 } 1051 } else { 1052 zsv_ext2 += 1; 1053 dz_ext2 -= 1; 1054 } 1055 } else { 1056 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb; 1057 dz_ext0 = dz_ext1 = dz_ext2 = dz0 - 4 * SQUISH_CONSTANT_4D; 1058 } 1059 1060 if ((c \u0026amp; 0x08) != 0) { 1061 wsv_ext0 = wsv_ext1 = wsb + 1; 1062 wsv_ext2 = wsb + 2; 1063 dw_ext0 = dw_ext1 = dw0 - 1 - 4 * SQUISH_CONSTANT_4D; 1064 dw_ext2 = dw0 - 2 - 4 * SQUISH_CONSTANT_4D; 1065 } else { 1066 wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb; 1067 dw_ext0 = dw_ext1 = dw_ext2 = dw0 - 4 * SQUISH_CONSTANT_4D; 1068 } 1069 } else { //(1,1,1,1) is not one of the closest two pentachoron vertices. 1070 byte c = (byte)(aPoint \u0026amp; bPoint); //Our three extra vertices are determined by the closest two. 1071 1072 if ((c \u0026amp; 0x01) != 0) { 1073 xsv_ext0 = xsv_ext2 = xsb + 1; 1074 xsv_ext1 = xsb + 2; 1075 dx_ext0 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1076 dx_ext1 = dx0 - 2 - 3 * SQUISH_CONSTANT_4D; 1077 dx_ext2 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D; 1078 } else { 1079 xsv_ext0 = xsv_ext1 = xsv_ext2 = xsb; 1080 dx_ext0 = dx0 - 2 * SQUISH_CONSTANT_4D; 1081 dx_ext1 = dx_ext2 = dx0 - 3 * SQUISH_CONSTANT_4D; 1082 } 1083 1084 if ((c \u0026amp; 0x02) != 0) { 1085 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb + 1; 1086 dy_ext0 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1087 dy_ext1 = dy_ext2 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D; 1088 if ((c \u0026amp; 0x01) != 0) { 1089 ysv_ext2 += 1; 1090 dy_ext2 -= 1; 1091 } else { 1092 ysv_ext1 += 1; 1093 dy_ext1 -= 1; 1094 } 1095 } else { 1096 ysv_ext0 = ysv_ext1 = ysv_ext2 = ysb; 1097 dy_ext0 = dy0 - 2 * SQUISH_CONSTANT_4D; 1098 dy_ext1 = dy_ext2 = dy0 - 3 * SQUISH_CONSTANT_4D; 1099 } 1100 1101 if ((c \u0026amp; 0x04) != 0) { 1102 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb + 1; 1103 dz_ext0 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1104 dz_ext1 = dz_ext2 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D; 1105 if ((c \u0026amp; 0x03) != 0) { 1106 zsv_ext2 += 1; 1107 dz_ext2 -= 1; 1108 } else { 1109 zsv_ext1 += 1; 1110 dz_ext1 -= 1; 1111 } 1112 } else { 1113 zsv_ext0 = zsv_ext1 = zsv_ext2 = zsb; 1114 dz_ext0 = dz0 - 2 * SQUISH_CONSTANT_4D; 1115 dz_ext1 = dz_ext2 = dz0 - 3 * SQUISH_CONSTANT_4D; 1116 } 1117 1118 if ((c \u0026amp; 0x08) != 0) { 1119 wsv_ext0 = wsv_ext1 = wsb + 1; 1120 wsv_ext2 = wsb + 2; 1121 dw_ext0 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1122 dw_ext1 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D; 1123 dw_ext2 = dw0 - 2 - 3 * SQUISH_CONSTANT_4D; 1124 } else { 1125 wsv_ext0 = wsv_ext1 = wsv_ext2 = wsb; 1126 dw_ext0 = dw0 - 2 * SQUISH_CONSTANT_4D; 1127 dw_ext1 = dw_ext2 = dw0 - 3 * SQUISH_CONSTANT_4D; 1128 } 1129 } 1130 1131 //Contribution (1,1,1,0) 1132 double dx4 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D; 1133 double dy4 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D; 1134 double dz4 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D; 1135 double dw4 = dw0 - 3 * SQUISH_CONSTANT_4D; 1136 double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4; 1137 if (attn4 \u0026gt; 0) { 1138 attn4 *= attn4; 1139 value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 1, wsb + 0, dx4, dy4, dz4, dw4); 1140 } 1141 1142 //Contribution (1,1,0,1) 1143 double dx3 = dx4; 1144 double dy3 = dy4; 1145 double dz3 = dz0 - 3 * SQUISH_CONSTANT_4D; 1146 double dw3 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D; 1147 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3; 1148 if (attn3 \u0026gt; 0) { 1149 attn3 *= attn3; 1150 value += attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 1, dx3, dy3, dz3, dw3); 1151 } 1152 1153 //Contribution (1,0,1,1) 1154 double dx2 = dx4; 1155 double dy2 = dy0 - 3 * SQUISH_CONSTANT_4D; 1156 double dz2 = dz4; 1157 double dw2 = dw3; 1158 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2; 1159 if (attn2 \u0026gt; 0) { 1160 attn2 *= attn2; 1161 value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 1, dx2, dy2, dz2, dw2); 1162 } 1163 1164 //Contribution (0,1,1,1) 1165 double dx1 = dx0 - 3 * SQUISH_CONSTANT_4D; 1166 double dz1 = dz4; 1167 double dy1 = dy4; 1168 double dw1 = dw3; 1169 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1; 1170 if (attn1 \u0026gt; 0) { 1171 attn1 *= attn1; 1172 value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 1, dx1, dy1, dz1, dw1); 1173 } 1174 1175 //Contribution (1,1,1,1) 1176 dx0 = dx0 - 1 - 4 * SQUISH_CONSTANT_4D; 1177 dy0 = dy0 - 1 - 4 * SQUISH_CONSTANT_4D; 1178 dz0 = dz0 - 1 - 4 * SQUISH_CONSTANT_4D; 1179 dw0 = dw0 - 1 - 4 * SQUISH_CONSTANT_4D; 1180 double attn0 = 2 - dx0 * dx0 - dy0 * dy0 - dz0 * dz0 - dw0 * dw0; 1181 if (attn0 \u0026gt; 0) { 1182 attn0 *= attn0; 1183 value += attn0 * attn0 * extrapolate(xsb + 1, ysb + 1, zsb + 1, wsb + 1, dx0, dy0, dz0, dw0); 1184 } 1185 } else if (inSum \u0026lt;= 2) { //We\u0026#39;re inside the first dispentachoron (Rectified 4-Simplex) 1186 double aScore; 1187 byte aPoint; 1188 boolean aIsBiggerSide = true; 1189 double bScore; 1190 byte bPoint; 1191 boolean bIsBiggerSide = true; 1192 1193 //Decide between (1,1,0,0) and (0,0,1,1) 1194 if (xins + yins \u0026gt; zins + wins) { 1195 aScore = xins + yins; 1196 aPoint = 0x03; 1197 } else { 1198 aScore = zins + wins; 1199 aPoint = 0x0C; 1200 } 1201 1202 //Decide between (1,0,1,0) and (0,1,0,1) 1203 if (xins + zins \u0026gt; yins + wins) { 1204 bScore = xins + zins; 1205 bPoint = 0x05; 1206 } else { 1207 bScore = yins + wins; 1208 bPoint = 0x0A; 1209 } 1210 1211 //Closer between (1,0,0,1) and (0,1,1,0) will replace the further of a and b, if closer. 1212 if (xins + wins \u0026gt; yins + zins) { 1213 double score = xins + wins; 1214 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; score \u0026gt; bScore) { 1215 bScore = score; 1216 bPoint = 0x09; 1217 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; score \u0026gt; aScore) { 1218 aScore = score; 1219 aPoint = 0x09; 1220 } 1221 } else { 1222 double score = yins + zins; 1223 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; score \u0026gt; bScore) { 1224 bScore = score; 1225 bPoint = 0x06; 1226 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; score \u0026gt; aScore) { 1227 aScore = score; 1228 aPoint = 0x06; 1229 } 1230 } 1231 1232 //Decide if (1,0,0,0) is closer. 1233 double p1 = 2 - inSum + xins; 1234 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; p1 \u0026gt; bScore) { 1235 bScore = p1; 1236 bPoint = 0x01; 1237 bIsBiggerSide = false; 1238 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; p1 \u0026gt; aScore) { 1239 aScore = p1; 1240 aPoint = 0x01; 1241 aIsBiggerSide = false; 1242 } 1243 1244 //Decide if (0,1,0,0) is closer. 1245 double p2 = 2 - inSum + yins; 1246 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; p2 \u0026gt; bScore) { 1247 bScore = p2; 1248 bPoint = 0x02; 1249 bIsBiggerSide = false; 1250 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; p2 \u0026gt; aScore) { 1251 aScore = p2; 1252 aPoint = 0x02; 1253 aIsBiggerSide = false; 1254 } 1255 1256 //Decide if (0,0,1,0) is closer. 1257 double p3 = 2 - inSum + zins; 1258 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; p3 \u0026gt; bScore) { 1259 bScore = p3; 1260 bPoint = 0x04; 1261 bIsBiggerSide = false; 1262 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; p3 \u0026gt; aScore) { 1263 aScore = p3; 1264 aPoint = 0x04; 1265 aIsBiggerSide = false; 1266 } 1267 1268 //Decide if (0,0,0,1) is closer. 1269 double p4 = 2 - inSum + wins; 1270 if (aScore \u0026gt;= bScore \u0026amp;\u0026amp; p4 \u0026gt; bScore) { 1271 bScore = p4; 1272 bPoint = 0x08; 1273 bIsBiggerSide = false; 1274 } else if (aScore \u0026lt; bScore \u0026amp;\u0026amp; p4 \u0026gt; aScore) { 1275 aScore = p4; 1276 aPoint = 0x08; 1277 aIsBiggerSide = false; 1278 } 1279 1280 //Where each of the two closest points are determines how the extra three vertices are calculated. 1281 if (aIsBiggerSide == bIsBiggerSide) { 1282 if (aIsBiggerSide) { //Both closest points on the bigger side 1283 byte c1 = (byte)(aPoint | bPoint); 1284 byte c2 = (byte)(aPoint \u0026amp; bPoint); 1285 if ((c1 \u0026amp; 0x01) == 0) { 1286 xsv_ext0 = xsb; 1287 xsv_ext1 = xsb - 1; 1288 dx_ext0 = dx0 - 3 * SQUISH_CONSTANT_4D; 1289 dx_ext1 = dx0 + 1 - 2 * SQUISH_CONSTANT_4D; 1290 } else { 1291 xsv_ext0 = xsv_ext1 = xsb + 1; 1292 dx_ext0 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D; 1293 dx_ext1 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1294 } 1295 1296 if ((c1 \u0026amp; 0x02) == 0) { 1297 ysv_ext0 = ysb; 1298 ysv_ext1 = ysb - 1; 1299 dy_ext0 = dy0 - 3 * SQUISH_CONSTANT_4D; 1300 dy_ext1 = dy0 + 1 - 2 * SQUISH_CONSTANT_4D; 1301 } else { 1302 ysv_ext0 = ysv_ext1 = ysb + 1; 1303 dy_ext0 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D; 1304 dy_ext1 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1305 } 1306 1307 if ((c1 \u0026amp; 0x04) == 0) { 1308 zsv_ext0 = zsb; 1309 zsv_ext1 = zsb - 1; 1310 dz_ext0 = dz0 - 3 * SQUISH_CONSTANT_4D; 1311 dz_ext1 = dz0 + 1 - 2 * SQUISH_CONSTANT_4D; 1312 } else { 1313 zsv_ext0 = zsv_ext1 = zsb + 1; 1314 dz_ext0 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D; 1315 dz_ext1 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1316 } 1317 1318 if ((c1 \u0026amp; 0x08) == 0) { 1319 wsv_ext0 = wsb; 1320 wsv_ext1 = wsb - 1; 1321 dw_ext0 = dw0 - 3 * SQUISH_CONSTANT_4D; 1322 dw_ext1 = dw0 + 1 - 2 * SQUISH_CONSTANT_4D; 1323 } else { 1324 wsv_ext0 = wsv_ext1 = wsb + 1; 1325 dw_ext0 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D; 1326 dw_ext1 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1327 } 1328 1329 //One combination is a permutation of (0,0,0,2) based on c2 1330 xsv_ext2 = xsb; 1331 ysv_ext2 = ysb; 1332 zsv_ext2 = zsb; 1333 wsv_ext2 = wsb; 1334 dx_ext2 = dx0 - 2 * SQUISH_CONSTANT_4D; 1335 dy_ext2 = dy0 - 2 * SQUISH_CONSTANT_4D; 1336 dz_ext2 = dz0 - 2 * SQUISH_CONSTANT_4D; 1337 dw_ext2 = dw0 - 2 * SQUISH_CONSTANT_4D; 1338 if ((c2 \u0026amp; 0x01) != 0) { 1339 xsv_ext2 += 2; 1340 dx_ext2 -= 2; 1341 } else if ((c2 \u0026amp; 0x02) != 0) { 1342 ysv_ext2 += 2; 1343 dy_ext2 -= 2; 1344 } else if ((c2 \u0026amp; 0x04) != 0) { 1345 zsv_ext2 += 2; 1346 dz_ext2 -= 2; 1347 } else { 1348 wsv_ext2 += 2; 1349 dw_ext2 -= 2; 1350 } 1351 1352 } else { //Both closest points on the smaller side 1353 //One of the two extra points is (0,0,0,0) 1354 xsv_ext2 = xsb; 1355 ysv_ext2 = ysb; 1356 zsv_ext2 = zsb; 1357 wsv_ext2 = wsb; 1358 dx_ext2 = dx0; 1359 dy_ext2 = dy0; 1360 dz_ext2 = dz0; 1361 dw_ext2 = dw0; 1362 1363 //Other two points are based on the omitted axes. 1364 byte c = (byte)(aPoint | bPoint); 1365 1366 if ((c \u0026amp; 0x01) == 0) { 1367 xsv_ext0 = xsb - 1; 1368 xsv_ext1 = xsb; 1369 dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_4D; 1370 dx_ext1 = dx0 - SQUISH_CONSTANT_4D; 1371 } else { 1372 xsv_ext0 = xsv_ext1 = xsb + 1; 1373 dx_ext0 = dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_4D; 1374 } 1375 1376 if ((c \u0026amp; 0x02) == 0) { 1377 ysv_ext0 = ysv_ext1 = ysb; 1378 dy_ext0 = dy_ext1 = dy0 - SQUISH_CONSTANT_4D; 1379 if ((c \u0026amp; 0x01) == 0x01) 1380 { 1381 ysv_ext0 -= 1; 1382 dy_ext0 += 1; 1383 } else { 1384 ysv_ext1 -= 1; 1385 dy_ext1 += 1; 1386 } 1387 } else { 1388 ysv_ext0 = ysv_ext1 = ysb + 1; 1389 dy_ext0 = dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_4D; 1390 } 1391 1392 if ((c \u0026amp; 0x04) == 0) { 1393 zsv_ext0 = zsv_ext1 = zsb; 1394 dz_ext0 = dz_ext1 = dz0 - SQUISH_CONSTANT_4D; 1395 if ((c \u0026amp; 0x03) == 0x03) 1396 { 1397 zsv_ext0 -= 1; 1398 dz_ext0 += 1; 1399 } else { 1400 zsv_ext1 -= 1; 1401 dz_ext1 += 1; 1402 } 1403 } else { 1404 zsv_ext0 = zsv_ext1 = zsb + 1; 1405 dz_ext0 = dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_4D; 1406 } 1407 1408 if ((c \u0026amp; 0x08) == 0) 1409 { 1410 wsv_ext0 = wsb; 1411 wsv_ext1 = wsb - 1; 1412 dw_ext0 = dw0 - SQUISH_CONSTANT_4D; 1413 dw_ext1 = dw0 + 1 - SQUISH_CONSTANT_4D; 1414 } else { 1415 wsv_ext0 = wsv_ext1 = wsb + 1; 1416 dw_ext0 = dw_ext1 = dw0 - 1 - SQUISH_CONSTANT_4D; 1417 } 1418 1419 } 1420 } else { //One point on each \u0026#34;side\u0026#34; 1421 byte c1, c2; 1422 if (aIsBiggerSide) { 1423 c1 = aPoint; 1424 c2 = bPoint; 1425 } else { 1426 c1 = bPoint; 1427 c2 = aPoint; 1428 } 1429 1430 //Two contributions are the bigger-sided point with each 0 replaced with -1. 1431 if ((c1 \u0026amp; 0x01) == 0) { 1432 xsv_ext0 = xsb - 1; 1433 xsv_ext1 = xsb; 1434 dx_ext0 = dx0 + 1 - SQUISH_CONSTANT_4D; 1435 dx_ext1 = dx0 - SQUISH_CONSTANT_4D; 1436 } else { 1437 xsv_ext0 = xsv_ext1 = xsb + 1; 1438 dx_ext0 = dx_ext1 = dx0 - 1 - SQUISH_CONSTANT_4D; 1439 } 1440 1441 if ((c1 \u0026amp; 0x02) == 0) { 1442 ysv_ext0 = ysv_ext1 = ysb; 1443 dy_ext0 = dy_ext1 = dy0 - SQUISH_CONSTANT_4D; 1444 if ((c1 \u0026amp; 0x01) == 0x01) { 1445 ysv_ext0 -= 1; 1446 dy_ext0 += 1; 1447 } else { 1448 ysv_ext1 -= 1; 1449 dy_ext1 += 1; 1450 } 1451 } else { 1452 ysv_ext0 = ysv_ext1 = ysb + 1; 1453 dy_ext0 = dy_ext1 = dy0 - 1 - SQUISH_CONSTANT_4D; 1454 } 1455 1456 if ((c1 \u0026amp; 0x04) == 0) { 1457 zsv_ext0 = zsv_ext1 = zsb; 1458 dz_ext0 = dz_ext1 = dz0 - SQUISH_CONSTANT_4D; 1459 if ((c1 \u0026amp; 0x03) == 0x03) { 1460 zsv_ext0 -= 1; 1461 dz_ext0 += 1; 1462 } else { 1463 zsv_ext1 -= 1; 1464 dz_ext1 += 1; 1465 } 1466 } else { 1467 zsv_ext0 = zsv_ext1 = zsb + 1; 1468 dz_ext0 = dz_ext1 = dz0 - 1 - SQUISH_CONSTANT_4D; 1469 } 1470 1471 if ((c1 \u0026amp; 0x08) == 0) { 1472 wsv_ext0 = wsb; 1473 wsv_ext1 = wsb - 1; 1474 dw_ext0 = dw0 - SQUISH_CONSTANT_4D; 1475 dw_ext1 = dw0 + 1 - SQUISH_CONSTANT_4D; 1476 } else { 1477 wsv_ext0 = wsv_ext1 = wsb + 1; 1478 dw_ext0 = dw_ext1 = dw0 - 1 - SQUISH_CONSTANT_4D; 1479 } 1480 1481 //One contribution is a permutation of (0,0,0,2) based on the smaller-sided point 1482 xsv_ext2 = xsb; 1483 ysv_ext2 = ysb; 1484 zsv_ext2 = zsb; 1485 wsv_ext2 = wsb; 1486 dx_ext2 = dx0 - 2 * SQUISH_CONSTANT_4D; 1487 dy_ext2 = dy0 - 2 * SQUISH_CONSTANT_4D; 1488 dz_ext2 = dz0 - 2 * SQUISH_CONSTANT_4D; 1489 dw_ext2 = dw0 - 2 * SQUISH_CONSTANT_4D; 1490 if ((c2 \u0026amp; 0x01) != 0) { 1491 xsv_ext2 += 2; 1492 dx_ext2 -= 2; 1493 } else if ((c2 \u0026amp; 0x02) != 0) { 1494 ysv_ext2 += 2; 1495 dy_ext2 -= 2; 1496 } else if ((c2 \u0026amp; 0x04) != 0) { 1497 zsv_ext2 += 2; 1498 dz_ext2 -= 2; 1499 } else { 1500 wsv_ext2 += 2; 1501 dw_ext2 -= 2; 1502 } 1503 } 1504 1505 //Contribution (1,0,0,0) 1506 double dx1 = dx0 - 1 - SQUISH_CONSTANT_4D; 1507 double dy1 = dy0 - 0 - SQUISH_CONSTANT_4D; 1508 double dz1 = dz0 - 0 - SQUISH_CONSTANT_4D; 1509 double dw1 = dw0 - 0 - SQUISH_CONSTANT_4D; 1510 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1; 1511 if (attn1 \u0026gt; 0) { 1512 attn1 *= attn1; 1513 value += attn1 * attn1 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 0, dx1, dy1, dz1, dw1); 1514 } 1515 1516 //Contribution (0,1,0,0) 1517 double dx2 = dx0 - 0 - SQUISH_CONSTANT_4D; 1518 double dy2 = dy0 - 1 - SQUISH_CONSTANT_4D; 1519 double dz2 = dz1; 1520 double dw2 = dw1; 1521 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2; 1522 if (attn2 \u0026gt; 0) { 1523 attn2 *= attn2; 1524 value += attn2 * attn2 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 0, dx2, dy2, dz2, dw2); 1525 } 1526 1527 //Contribution (0,0,1,0) 1528 double dx3 = dx2; 1529 double dy3 = dy1; 1530 double dz3 = dz0 - 1 - SQUISH_CONSTANT_4D; 1531 double dw3 = dw1; 1532 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3; 1533 if (attn3 \u0026gt; 0) { 1534 attn3 *= attn3; 1535 value += attn3 * attn3 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 0, dx3, dy3, dz3, dw3); 1536 } 1537 1538 //Contribution (0,0,0,1) 1539 double dx4 = dx2; 1540 double dy4 = dy1; 1541 double dz4 = dz1; 1542 double dw4 = dw0 - 1 - SQUISH_CONSTANT_4D; 1543 double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4; 1544 if (attn4 \u0026gt; 0) { 1545 attn4 *= attn4; 1546 value += attn4 * attn4 * extrapolate(xsb + 0, ysb + 0, zsb + 0, wsb + 1, dx4, dy4, dz4, dw4); 1547 } 1548 1549 //Contribution (1,1,0,0) 1550 double dx5 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1551 double dy5 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1552 double dz5 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D; 1553 double dw5 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D; 1554 double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5 - dw5 * dw5; 1555 if (attn5 \u0026gt; 0) { 1556 attn5 *= attn5; 1557 value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 0, dx5, dy5, dz5, dw5); 1558 } 1559 1560 //Contribution (1,0,1,0) 1561 double dx6 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1562 double dy6 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D; 1563 double dz6 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1564 double dw6 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D; 1565 double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6 - dw6 * dw6; 1566 if (attn6 \u0026gt; 0) { 1567 attn6 *= attn6; 1568 value += attn6 * attn6 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 0, dx6, dy6, dz6, dw6); 1569 } 1570 1571 //Contribution (1,0,0,1) 1572 double dx7 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1573 double dy7 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D; 1574 double dz7 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D; 1575 double dw7 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1576 double attn7 = 2 - dx7 * dx7 - dy7 * dy7 - dz7 * dz7 - dw7 * dw7; 1577 if (attn7 \u0026gt; 0) { 1578 attn7 *= attn7; 1579 value += attn7 * attn7 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 1, dx7, dy7, dz7, dw7); 1580 } 1581 1582 //Contribution (0,1,1,0) 1583 double dx8 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D; 1584 double dy8 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1585 double dz8 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1586 double dw8 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D; 1587 double attn8 = 2 - dx8 * dx8 - dy8 * dy8 - dz8 * dz8 - dw8 * dw8; 1588 if (attn8 \u0026gt; 0) { 1589 attn8 *= attn8; 1590 value += attn8 * attn8 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 0, dx8, dy8, dz8, dw8); 1591 } 1592 1593 //Contribution (0,1,0,1) 1594 double dx9 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D; 1595 double dy9 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1596 double dz9 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D; 1597 double dw9 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1598 double attn9 = 2 - dx9 * dx9 - dy9 * dy9 - dz9 * dz9 - dw9 * dw9; 1599 if (attn9 \u0026gt; 0) { 1600 attn9 *= attn9; 1601 value += attn9 * attn9 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 1, dx9, dy9, dz9, dw9); 1602 } 1603 1604 //Contribution (0,0,1,1) 1605 double dx10 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D; 1606 double dy10 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D; 1607 double dz10 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1608 double dw10 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1609 double attn10 = 2 - dx10 * dx10 - dy10 * dy10 - dz10 * dz10 - dw10 * dw10; 1610 if (attn10 \u0026gt; 0) { 1611 attn10 *= attn10; 1612 value += attn10 * attn10 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 1, dx10, dy10, dz10, dw10); 1613 } 1614 } else { //We\u0026#39;re inside the second dispentachoron (Rectified 4-Simplex) 1615 double aScore; 1616 byte aPoint; 1617 boolean aIsBiggerSide = true; 1618 double bScore; 1619 byte bPoint; 1620 boolean bIsBiggerSide = true; 1621 1622 //Decide between (0,0,1,1) and (1,1,0,0) 1623 if (xins + yins \u0026lt; zins + wins) { 1624 aScore = xins + yins; 1625 aPoint = 0x0C; 1626 } else { 1627 aScore = zins + wins; 1628 aPoint = 0x03; 1629 } 1630 1631 //Decide between (0,1,0,1) and (1,0,1,0) 1632 if (xins + zins \u0026lt; yins + wins) { 1633 bScore = xins + zins; 1634 bPoint = 0x0A; 1635 } else { 1636 bScore = yins + wins; 1637 bPoint = 0x05; 1638 } 1639 1640 //Closer between (0,1,1,0) and (1,0,0,1) will replace the further of a and b, if closer. 1641 if (xins + wins \u0026lt; yins + zins) { 1642 double score = xins + wins; 1643 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; score \u0026lt; bScore) { 1644 bScore = score; 1645 bPoint = 0x06; 1646 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; score \u0026lt; aScore) { 1647 aScore = score; 1648 aPoint = 0x06; 1649 } 1650 } else { 1651 double score = yins + zins; 1652 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; score \u0026lt; bScore) { 1653 bScore = score; 1654 bPoint = 0x09; 1655 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; score \u0026lt; aScore) { 1656 aScore = score; 1657 aPoint = 0x09; 1658 } 1659 } 1660 1661 //Decide if (0,1,1,1) is closer. 1662 double p1 = 3 - inSum + xins; 1663 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; p1 \u0026lt; bScore) { 1664 bScore = p1; 1665 bPoint = 0x0E; 1666 bIsBiggerSide = false; 1667 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; p1 \u0026lt; aScore) { 1668 aScore = p1; 1669 aPoint = 0x0E; 1670 aIsBiggerSide = false; 1671 } 1672 1673 //Decide if (1,0,1,1) is closer. 1674 double p2 = 3 - inSum + yins; 1675 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; p2 \u0026lt; bScore) { 1676 bScore = p2; 1677 bPoint = 0x0D; 1678 bIsBiggerSide = false; 1679 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; p2 \u0026lt; aScore) { 1680 aScore = p2; 1681 aPoint = 0x0D; 1682 aIsBiggerSide = false; 1683 } 1684 1685 //Decide if (1,1,0,1) is closer. 1686 double p3 = 3 - inSum + zins; 1687 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; p3 \u0026lt; bScore) { 1688 bScore = p3; 1689 bPoint = 0x0B; 1690 bIsBiggerSide = false; 1691 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; p3 \u0026lt; aScore) { 1692 aScore = p3; 1693 aPoint = 0x0B; 1694 aIsBiggerSide = false; 1695 } 1696 1697 //Decide if (1,1,1,0) is closer. 1698 double p4 = 3 - inSum + wins; 1699 if (aScore \u0026lt;= bScore \u0026amp;\u0026amp; p4 \u0026lt; bScore) { 1700 bScore = p4; 1701 bPoint = 0x07; 1702 bIsBiggerSide = false; 1703 } else if (aScore \u0026gt; bScore \u0026amp;\u0026amp; p4 \u0026lt; aScore) { 1704 aScore = p4; 1705 aPoint = 0x07; 1706 aIsBiggerSide = false; 1707 } 1708 1709 //Where each of the two closest points are determines how the extra three vertices are calculated. 1710 if (aIsBiggerSide == bIsBiggerSide) { 1711 if (aIsBiggerSide) { //Both closest points on the bigger side 1712 byte c1 = (byte)(aPoint \u0026amp; bPoint); 1713 byte c2 = (byte)(aPoint | bPoint); 1714 1715 //Two contributions are permutations of (0,0,0,1) and (0,0,0,2) based on c1 1716 xsv_ext0 = xsv_ext1 = xsb; 1717 ysv_ext0 = ysv_ext1 = ysb; 1718 zsv_ext0 = zsv_ext1 = zsb; 1719 wsv_ext0 = wsv_ext1 = wsb; 1720 dx_ext0 = dx0 - SQUISH_CONSTANT_4D; 1721 dy_ext0 = dy0 - SQUISH_CONSTANT_4D; 1722 dz_ext0 = dz0 - SQUISH_CONSTANT_4D; 1723 dw_ext0 = dw0 - SQUISH_CONSTANT_4D; 1724 dx_ext1 = dx0 - 2 * SQUISH_CONSTANT_4D; 1725 dy_ext1 = dy0 - 2 * SQUISH_CONSTANT_4D; 1726 dz_ext1 = dz0 - 2 * SQUISH_CONSTANT_4D; 1727 dw_ext1 = dw0 - 2 * SQUISH_CONSTANT_4D; 1728 if ((c1 \u0026amp; 0x01) != 0) { 1729 xsv_ext0 += 1; 1730 dx_ext0 -= 1; 1731 xsv_ext1 += 2; 1732 dx_ext1 -= 2; 1733 } else if ((c1 \u0026amp; 0x02) != 0) { 1734 ysv_ext0 += 1; 1735 dy_ext0 -= 1; 1736 ysv_ext1 += 2; 1737 dy_ext1 -= 2; 1738 } else if ((c1 \u0026amp; 0x04) != 0) { 1739 zsv_ext0 += 1; 1740 dz_ext0 -= 1; 1741 zsv_ext1 += 2; 1742 dz_ext1 -= 2; 1743 } else { 1744 wsv_ext0 += 1; 1745 dw_ext0 -= 1; 1746 wsv_ext1 += 2; 1747 dw_ext1 -= 2; 1748 } 1749 1750 //One contribution is a permutation of (1,1,1,-1) based on c2 1751 xsv_ext2 = xsb + 1; 1752 ysv_ext2 = ysb + 1; 1753 zsv_ext2 = zsb + 1; 1754 wsv_ext2 = wsb + 1; 1755 dx_ext2 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1756 dy_ext2 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1757 dz_ext2 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1758 dw_ext2 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1759 if ((c2 \u0026amp; 0x01) == 0) { 1760 xsv_ext2 -= 2; 1761 dx_ext2 += 2; 1762 } else if ((c2 \u0026amp; 0x02) == 0) { 1763 ysv_ext2 -= 2; 1764 dy_ext2 += 2; 1765 } else if ((c2 \u0026amp; 0x04) == 0) { 1766 zsv_ext2 -= 2; 1767 dz_ext2 += 2; 1768 } else { 1769 wsv_ext2 -= 2; 1770 dw_ext2 += 2; 1771 } 1772 } else { //Both closest points on the smaller side 1773 //One of the two extra points is (1,1,1,1) 1774 xsv_ext2 = xsb + 1; 1775 ysv_ext2 = ysb + 1; 1776 zsv_ext2 = zsb + 1; 1777 wsv_ext2 = wsb + 1; 1778 dx_ext2 = dx0 - 1 - 4 * SQUISH_CONSTANT_4D; 1779 dy_ext2 = dy0 - 1 - 4 * SQUISH_CONSTANT_4D; 1780 dz_ext2 = dz0 - 1 - 4 * SQUISH_CONSTANT_4D; 1781 dw_ext2 = dw0 - 1 - 4 * SQUISH_CONSTANT_4D; 1782 1783 //Other two points are based on the shared axes. 1784 byte c = (byte)(aPoint \u0026amp; bPoint); 1785 1786 if ((c \u0026amp; 0x01) != 0) { 1787 xsv_ext0 = xsb + 2; 1788 xsv_ext1 = xsb + 1; 1789 dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_4D; 1790 dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D; 1791 } else { 1792 xsv_ext0 = xsv_ext1 = xsb; 1793 dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_4D; 1794 } 1795 1796 if ((c \u0026amp; 0x02) != 0) { 1797 ysv_ext0 = ysv_ext1 = ysb + 1; 1798 dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D; 1799 if ((c \u0026amp; 0x01) == 0) 1800 { 1801 ysv_ext0 += 1; 1802 dy_ext0 -= 1; 1803 } else { 1804 ysv_ext1 += 1; 1805 dy_ext1 -= 1; 1806 } 1807 } else { 1808 ysv_ext0 = ysv_ext1 = ysb; 1809 dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_4D; 1810 } 1811 1812 if ((c \u0026amp; 0x04) != 0) { 1813 zsv_ext0 = zsv_ext1 = zsb + 1; 1814 dz_ext0 = dz_ext1 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D; 1815 if ((c \u0026amp; 0x03) == 0) 1816 { 1817 zsv_ext0 += 1; 1818 dz_ext0 -= 1; 1819 } else { 1820 zsv_ext1 += 1; 1821 dz_ext1 -= 1; 1822 } 1823 } else { 1824 zsv_ext0 = zsv_ext1 = zsb; 1825 dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_4D; 1826 } 1827 1828 if ((c \u0026amp; 0x08) != 0) 1829 { 1830 wsv_ext0 = wsb + 1; 1831 wsv_ext1 = wsb + 2; 1832 dw_ext0 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D; 1833 dw_ext1 = dw0 - 2 - 3 * SQUISH_CONSTANT_4D; 1834 } else { 1835 wsv_ext0 = wsv_ext1 = wsb; 1836 dw_ext0 = dw_ext1 = dw0 - 3 * SQUISH_CONSTANT_4D; 1837 } 1838 } 1839 } else { //One point on each \u0026#34;side\u0026#34; 1840 byte c1, c2; 1841 if (aIsBiggerSide) { 1842 c1 = aPoint; 1843 c2 = bPoint; 1844 } else { 1845 c1 = bPoint; 1846 c2 = aPoint; 1847 } 1848 1849 //Two contributions are the bigger-sided point with each 1 replaced with 2. 1850 if ((c1 \u0026amp; 0x01) != 0) { 1851 xsv_ext0 = xsb + 2; 1852 xsv_ext1 = xsb + 1; 1853 dx_ext0 = dx0 - 2 - 3 * SQUISH_CONSTANT_4D; 1854 dx_ext1 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D; 1855 } else { 1856 xsv_ext0 = xsv_ext1 = xsb; 1857 dx_ext0 = dx_ext1 = dx0 - 3 * SQUISH_CONSTANT_4D; 1858 } 1859 1860 if ((c1 \u0026amp; 0x02) != 0) { 1861 ysv_ext0 = ysv_ext1 = ysb + 1; 1862 dy_ext0 = dy_ext1 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D; 1863 if ((c1 \u0026amp; 0x01) == 0) { 1864 ysv_ext0 += 1; 1865 dy_ext0 -= 1; 1866 } else { 1867 ysv_ext1 += 1; 1868 dy_ext1 -= 1; 1869 } 1870 } else { 1871 ysv_ext0 = ysv_ext1 = ysb; 1872 dy_ext0 = dy_ext1 = dy0 - 3 * SQUISH_CONSTANT_4D; 1873 } 1874 1875 if ((c1 \u0026amp; 0x04) != 0) { 1876 zsv_ext0 = zsv_ext1 = zsb + 1; 1877 dz_ext0 = dz_ext1 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D; 1878 if ((c1 \u0026amp; 0x03) == 0) { 1879 zsv_ext0 += 1; 1880 dz_ext0 -= 1; 1881 } else { 1882 zsv_ext1 += 1; 1883 dz_ext1 -= 1; 1884 } 1885 } else { 1886 zsv_ext0 = zsv_ext1 = zsb; 1887 dz_ext0 = dz_ext1 = dz0 - 3 * SQUISH_CONSTANT_4D; 1888 } 1889 1890 if ((c1 \u0026amp; 0x08) != 0) { 1891 wsv_ext0 = wsb + 1; 1892 wsv_ext1 = wsb + 2; 1893 dw_ext0 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D; 1894 dw_ext1 = dw0 - 2 - 3 * SQUISH_CONSTANT_4D; 1895 } else { 1896 wsv_ext0 = wsv_ext1 = wsb; 1897 dw_ext0 = dw_ext1 = dw0 - 3 * SQUISH_CONSTANT_4D; 1898 } 1899 1900 //One contribution is a permutation of (1,1,1,-1) based on the smaller-sided point 1901 xsv_ext2 = xsb + 1; 1902 ysv_ext2 = ysb + 1; 1903 zsv_ext2 = zsb + 1; 1904 wsv_ext2 = wsb + 1; 1905 dx_ext2 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1906 dy_ext2 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1907 dz_ext2 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1908 dw_ext2 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1909 if ((c2 \u0026amp; 0x01) == 0) { 1910 xsv_ext2 -= 2; 1911 dx_ext2 += 2; 1912 } else if ((c2 \u0026amp; 0x02) == 0) { 1913 ysv_ext2 -= 2; 1914 dy_ext2 += 2; 1915 } else if ((c2 \u0026amp; 0x04) == 0) { 1916 zsv_ext2 -= 2; 1917 dz_ext2 += 2; 1918 } else { 1919 wsv_ext2 -= 2; 1920 dw_ext2 += 2; 1921 } 1922 } 1923 1924 //Contribution (1,1,1,0) 1925 double dx4 = dx0 - 1 - 3 * SQUISH_CONSTANT_4D; 1926 double dy4 = dy0 - 1 - 3 * SQUISH_CONSTANT_4D; 1927 double dz4 = dz0 - 1 - 3 * SQUISH_CONSTANT_4D; 1928 double dw4 = dw0 - 3 * SQUISH_CONSTANT_4D; 1929 double attn4 = 2 - dx4 * dx4 - dy4 * dy4 - dz4 * dz4 - dw4 * dw4; 1930 if (attn4 \u0026gt; 0) { 1931 attn4 *= attn4; 1932 value += attn4 * attn4 * extrapolate(xsb + 1, ysb + 1, zsb + 1, wsb + 0, dx4, dy4, dz4, dw4); 1933 } 1934 1935 //Contribution (1,1,0,1) 1936 double dx3 = dx4; 1937 double dy3 = dy4; 1938 double dz3 = dz0 - 3 * SQUISH_CONSTANT_4D; 1939 double dw3 = dw0 - 1 - 3 * SQUISH_CONSTANT_4D; 1940 double attn3 = 2 - dx3 * dx3 - dy3 * dy3 - dz3 * dz3 - dw3 * dw3; 1941 if (attn3 \u0026gt; 0) { 1942 attn3 *= attn3; 1943 value += attn3 * attn3 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 1, dx3, dy3, dz3, dw3); 1944 } 1945 1946 //Contribution (1,0,1,1) 1947 double dx2 = dx4; 1948 double dy2 = dy0 - 3 * SQUISH_CONSTANT_4D; 1949 double dz2 = dz4; 1950 double dw2 = dw3; 1951 double attn2 = 2 - dx2 * dx2 - dy2 * dy2 - dz2 * dz2 - dw2 * dw2; 1952 if (attn2 \u0026gt; 0) { 1953 attn2 *= attn2; 1954 value += attn2 * attn2 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 1, dx2, dy2, dz2, dw2); 1955 } 1956 1957 //Contribution (0,1,1,1) 1958 double dx1 = dx0 - 3 * SQUISH_CONSTANT_4D; 1959 double dz1 = dz4; 1960 double dy1 = dy4; 1961 double dw1 = dw3; 1962 double attn1 = 2 - dx1 * dx1 - dy1 * dy1 - dz1 * dz1 - dw1 * dw1; 1963 if (attn1 \u0026gt; 0) { 1964 attn1 *= attn1; 1965 value += attn1 * attn1 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 1, dx1, dy1, dz1, dw1); 1966 } 1967 1968 //Contribution (1,1,0,0) 1969 double dx5 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1970 double dy5 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 1971 double dz5 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D; 1972 double dw5 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D; 1973 double attn5 = 2 - dx5 * dx5 - dy5 * dy5 - dz5 * dz5 - dw5 * dw5; 1974 if (attn5 \u0026gt; 0) { 1975 attn5 *= attn5; 1976 value += attn5 * attn5 * extrapolate(xsb + 1, ysb + 1, zsb + 0, wsb + 0, dx5, dy5, dz5, dw5); 1977 } 1978 1979 //Contribution (1,0,1,0) 1980 double dx6 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1981 double dy6 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D; 1982 double dz6 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 1983 double dw6 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D; 1984 double attn6 = 2 - dx6 * dx6 - dy6 * dy6 - dz6 * dz6 - dw6 * dw6; 1985 if (attn6 \u0026gt; 0) { 1986 attn6 *= attn6; 1987 value += attn6 * attn6 * extrapolate(xsb + 1, ysb + 0, zsb + 1, wsb + 0, dx6, dy6, dz6, dw6); 1988 } 1989 1990 //Contribution (1,0,0,1) 1991 double dx7 = dx0 - 1 - 2 * SQUISH_CONSTANT_4D; 1992 double dy7 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D; 1993 double dz7 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D; 1994 double dw7 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 1995 double attn7 = 2 - dx7 * dx7 - dy7 * dy7 - dz7 * dz7 - dw7 * dw7; 1996 if (attn7 \u0026gt; 0) { 1997 attn7 *= attn7; 1998 value += attn7 * attn7 * extrapolate(xsb + 1, ysb + 0, zsb + 0, wsb + 1, dx7, dy7, dz7, dw7); 1999 } 2000 2001 //Contribution (0,1,1,0) 2002 double dx8 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D; 2003 double dy8 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 2004 double dz8 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 2005 double dw8 = dw0 - 0 - 2 * SQUISH_CONSTANT_4D; 2006 double attn8 = 2 - dx8 * dx8 - dy8 * dy8 - dz8 * dz8 - dw8 * dw8; 2007 if (attn8 \u0026gt; 0) { 2008 attn8 *= attn8; 2009 value += attn8 * attn8 * extrapolate(xsb + 0, ysb + 1, zsb + 1, wsb + 0, dx8, dy8, dz8, dw8); 2010 } 2011 2012 //Contribution (0,1,0,1) 2013 double dx9 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D; 2014 double dy9 = dy0 - 1 - 2 * SQUISH_CONSTANT_4D; 2015 double dz9 = dz0 - 0 - 2 * SQUISH_CONSTANT_4D; 2016 double dw9 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 2017 double attn9 = 2 - dx9 * dx9 - dy9 * dy9 - dz9 * dz9 - dw9 * dw9; 2018 if (attn9 \u0026gt; 0) { 2019 attn9 *= attn9; 2020 value += attn9 * attn9 * extrapolate(xsb + 0, ysb + 1, zsb + 0, wsb + 1, dx9, dy9, dz9, dw9); 2021 } 2022 2023 //Contribution (0,0,1,1) 2024 double dx10 = dx0 - 0 - 2 * SQUISH_CONSTANT_4D; 2025 double dy10 = dy0 - 0 - 2 * SQUISH_CONSTANT_4D; 2026 double dz10 = dz0 - 1 - 2 * SQUISH_CONSTANT_4D; 2027 double dw10 = dw0 - 1 - 2 * SQUISH_CONSTANT_4D; 2028 double attn10 = 2 - dx10 * dx10 - dy10 * dy10 - dz10 * dz10 - dw10 * dw10; 2029 if (attn10 \u0026gt; 0) { 2030 attn10 *= attn10; 2031 value += attn10 * attn10 * extrapolate(xsb + 0, ysb + 0, zsb + 1, wsb + 1, dx10, dy10, dz10, dw10); 2032 } 2033 } 2034 2035 //First extra vertex 2036 double attn_ext0 = 2 - dx_ext0 * dx_ext0 - dy_ext0 * dy_ext0 - dz_ext0 * dz_ext0 - dw_ext0 * dw_ext0; 2037 if (attn_ext0 \u0026gt; 0) 2038 { 2039 attn_ext0 *= attn_ext0; 2040 value += attn_ext0 * attn_ext0 * extrapolate(xsv_ext0, ysv_ext0, zsv_ext0, wsv_ext0, dx_ext0, dy_ext0, dz_ext0, dw_ext0); 2041 } 2042 2043 //Second extra vertex 2044 double attn_ext1 = 2 - dx_ext1 * dx_ext1 - dy_ext1 * dy_ext1 - dz_ext1 * dz_ext1 - dw_ext1 * dw_ext1; 2045 if (attn_ext1 \u0026gt; 0) 2046 { 2047 attn_ext1 *= attn_ext1; 2048 value += attn_ext1 * attn_ext1 * extrapolate(xsv_ext1, ysv_ext1, zsv_ext1, wsv_ext1, dx_ext1, dy_ext1, dz_ext1, dw_ext1); 2049 } 2050 2051 //Third extra vertex 2052 double attn_ext2 = 2 - dx_ext2 * dx_ext2 - dy_ext2 * dy_ext2 - dz_ext2 * dz_ext2 - dw_ext2 * dw_ext2; 2053 if (attn_ext2 \u0026gt; 0) 2054 { 2055 attn_ext2 *= attn_ext2; 2056 value += attn_ext2 * attn_ext2 * extrapolate(xsv_ext2, ysv_ext2, zsv_ext2, wsv_ext2, dx_ext2, dy_ext2, dz_ext2, dw_ext2); 2057 } 2058 2059 return value / NORM_CONSTANT_4D; 2060 } 2061 2062 private double extrapolate(int xsb, int ysb, double dx, double dy) 2063 { 2064 int index = perm[(perm[xsb \u0026amp; 0xFF] + ysb) \u0026amp; 0xFF] \u0026amp; 0x0E; 2065 return gradients2D[index] * dx 2066 + gradients2D[index + 1] * dy; 2067 } 2068 2069 private double extrapolate(int xsb, int ysb, int zsb, double dx, double dy, double dz) 2070 { 2071 int index = permGradIndex3D[(perm[(perm[xsb \u0026amp; 0xFF] + ysb) \u0026amp; 0xFF] + zsb) \u0026amp; 0xFF]; 2072 return gradients3D[index] * dx 2073 + gradients3D[index + 1] * dy 2074 + gradients3D[index + 2] * dz; 2075 } 2076 2077 private double extrapolate(int xsb, int ysb, int zsb, int wsb, double dx, double dy, double dz, double dw) 2078 { 2079 int index = perm[(perm[(perm[(perm[xsb \u0026amp; 0xFF] + ysb) \u0026amp; 0xFF] + zsb) \u0026amp; 0xFF] + wsb) \u0026amp; 0xFF] \u0026amp; 0xFC; 2080 return gradients4D[index] * dx 2081 + gradients4D[index + 1] * dy 2082 + gradients4D[index + 2] * dz 2083 + gradients4D[index + 3] * dw; 2084 } 2085 2086 private static int fastFloor(double x) { 2087 int xi = (int)x; 2088 return x \u0026lt; xi ? xi - 1 : xi; 2089 } 2090 2091 //Gradients for 2D. They approximate the directions to the 2092 //vertices of an octagon from the center. 2093 private static byte[] gradients2D = new byte[] { 2094 5, 2, 2, 5, 2095 -5, 2, -2, 5, 2096 5, -2, 2, -5, 2097 -5, -2, -2, -5, 2098 }; 2099 2100 //Gradients for 3D. They approximate the directions to the 2101 //vertices of a rhombicuboctahedron from the center, skewed so 2102 //that the triangular and square facets can be inscribed inside 2103 //circles of the same radius. 2104 private static byte[] gradients3D = new byte[] { 2105 -11, 4, 4, -4, 11, 4, -4, 4, 11, 2106 11, 4, 4, 4, 11, 4, 4, 4, 11, 2107 -11, -4, 4, -4, -11, 4, -4, -4, 11, 2108 11, -4, 4, 4, -11, 4, 4, -4, 11, 2109 -11, 4, -4, -4, 11, -4, -4, 4, -11, 2110 11, 4, -4, 4, 11, -4, 4, 4, -11, 2111 -11, -4, -4, -4, -11, -4, -4, -4, -11, 2112 11, -4, -4, 4, -11, -4, 4, -4, -11, 2113 }; 2114 2115 //Gradients for 4D. They approximate the directions to the 2116 //vertices of a disprismatotesseractihexadecachoron from the center, 2117 //skewed so that the tetrahedral and cubic facets can be inscribed inside 2118 //spheres of the same radius. 2119 private static byte[] gradients4D = new byte[] { 2120 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 3, 2121 -3, 1, 1, 1, -1, 3, 1, 1, -1, 1, 3, 1, -1, 1, 1, 3, 2122 3, -1, 1, 1, 1, -3, 1, 1, 1, -1, 3, 1, 1, -1, 1, 3, 2123 -3, -1, 1, 1, -1, -3, 1, 1, -1, -1, 3, 1, -1, -1, 1, 3, 2124 3, 1, -1, 1, 1, 3, -1, 1, 1, 1, -3, 1, 1, 1, -1, 3, 2125 -3, 1, -1, 1, -1, 3, -1, 1, -1, 1, -3, 1, -1, 1, -1, 3, 2126 3, -1, -1, 1, 1, -3, -1, 1, 1, -1, -3, 1, 1, -1, -1, 3, 2127 -3, -1, -1, 1, -1, -3, -1, 1, -1, -1, -3, 1, -1, -1, -1, 3, 2128 3, 1, 1, -1, 1, 3, 1, -1, 1, 1, 3, -1, 1, 1, 1, -3, 2129 -3, 1, 1, -1, -1, 3, 1, -1, -1, 1, 3, -1, -1, 1, 1, -3, 2130 3, -1, 1, -1, 1, -3, 1, -1, 1, -1, 3, -1, 1, -1, 1, -3, 2131 -3, -1, 1, -1, -1, -3, 1, -1, -1, -1, 3, -1, -1, -1, 1, -3, 2132 3, 1, -1, -1, 1, 3, -1, -1, 1, 1, -3, -1, 1, 1, -1, -3, 2133 -3, 1, -1, -1, -1, 3, -1, -1, -1, 1, -3, -1, -1, 1, -1, -3, 2134 3, -1, -1, -1, 1, -3, -1, -1, 1, -1, -3, -1, 1, -1, -1, -3, 2135 -3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -3, 2136 }; 2137} ","link":"https://trimad.github.io/post/2019-08-18-blending-textures-with-open-simplex-noise/","section":"post","tags":["animation","open simplex noise"],"title":"Blending Textures With Open Simplex Noise"},{"body":"","link":"https://trimad.github.io/tags/open-simplex-noise/","section":"tags","tags":null,"title":"open simplex noise"},{"body":"","link":"https://trimad.github.io/archives/","section":"","tags":null,"title":""},{"body":"This batch file utilizes robocopy to mirror a list of files contained within \u0026quot;targets.txt\u0026quot; in the same directory.\n","link":"https://trimad.github.io/post/2019-02-28-robo-mirror/","section":"post","tags":["robocopy"],"title":"Robo Mirror"},{"body":"","link":"https://trimad.github.io/tags/robocopy/","section":"tags","tags":null,"title":"robocopy"},{"body":"Here's my take on... Daniel Shiffman's take on... Beesandbomb's take on the cube wave.\n1 2import peasy.*; 3import peasy.org.apache.commons.math.*; 4import peasy.org.apache.commons.math.geometry.*; 5 6PeasyCam cam; 7 8float angle = 0; 9int w = 16; 10float magicAngle; 11float maxD; 12int orthoBound = 2048; 13 14void setup() { 15 //fullScreen(P3D); 16 size(900, 900, P3D); 17 magicAngle = atan(1 / sqrt(2)); 18 maxD = dist(0, 0, height, height); 19 cam = new PeasyCam(this, 2048); 20 cam.setMinimumDistance(0); 21 cam.setMaximumDistance(4096); 22} 23 24void draw() { 25 background(0); 26 ortho(-orthoBound, orthoBound, orthoBound, -orthoBound, 0, orthoBound); 27 ambientLight(127, 127, 127); 28 //Red 29 pointLight(255, 127, 127, 0, 0, 0); 30 //Green 31 pointLight(127, 255, 127, width / 2, 0, height / 2); 32 //Blue 33 pointLight(127, 127, 255, 0, 0, height); 34 rotateX(-magicAngle); 35 rotateY(-QUARTER_PI); 36 37 for (int z = 0; z \u0026lt; height; z += w) { 38 for (int x = 0; x \u0026lt; width; x += w) { 39 pushMatrix(); 40 float d = dist(x, z, width / 2, height / 2); 41 float offset = map(d, 0, maxD, -PI, PI); 42 float a = angle + offset; 43 float howHigh = map(sin(a), -1, 1, w, height); 44 translate(x, 0, z); 45 shininess(15.0); 46 //ambientMaterial(255); 47 //specularMaterial(255); 48 //normalMaterial(); 49 //texture(img); 50 box(w, howHigh, w); 51 popMatrix(); 52 } 53 } 54 angle -= 0.01; 55}``` 56 57\u0026lt;h2\u0026gt;Sources\u0026lt;/h2\u0026gt; 58 59- \u0026lt;a href=\u0026#34;https://twitter.com/beesandbombs/status/940639806522085376\u0026#34;\u0026gt;https://twitter.com/beesandbombs/status/940639806522085376\u0026lt;/a\u0026gt; 60 61- \u0026lt;a href=\u0026#34;https://www.youtube.com/watch?v=H81Tdrmz2LA\u0026#34;\u0026gt;https://www.youtube.com/watch?v=H81Tdrmz2LA\u0026lt;/a\u0026gt; ","link":"https://trimad.github.io/post/2018-12-30-cube-wave/","section":"post","tags":["animation"],"title":"Cube Wave"},{"body":"In this sketch I turned every pixel of an image into a Lorenz System. I mapped the velocity of that system to the brightness value of the pixel. This was the result. Sadly, the Processing sketch I made this with is gone forever.\n","link":"https://trimad.github.io/post/2018-11-21-lorenz-doll/","section":"post","tags":["animation","lorenz system"],"title":"Lorenz Doll"},{"body":"","link":"https://trimad.github.io/tags/lorenz-system/","section":"tags","tags":null,"title":"lorenz system"},{"body":"The Barnsley Fern is a fractal pattern named after British mathematician Michael Barnsley. It is generated by an iterative process that involves repeatedly applying a set of geometric transformations to a simple initial shape. The resulting fern-like pattern displays self-similarity at different scales, and has applications in computer graphics, image compression, and chaos theory.\n1float x = 0; 2float y = 0; 3 4float[][] magicX = { 5 {0.00, 0.00}, 6 {0.85, 0.04}, 7 {0.20, -0.26}, 8 {-0.15, 0.28} 9}; 10 11float[][] magicY = { 12 {0.16, 0.00, 0.00}, 13 {-0.04, 0.85, 1.6}, 14 {0.23, 0.22, 1.6}, 15 {0.26, 0.24, 0.44} 16}; 17 18//PGraphics pg; 19 20int iterations = 123456; 21 22void setup() { 23 //fullScreen(P3D); 24 size(2048, 2048, P3D); 25 background(0); 26 histogram = new int[width][height]; 27 //pg = createGraphics(width*2, height*2); 28 //pg.beginDraw(); 29 //pg.background(0, 50); 30 //pg.endDraw(); 31} 32 33boolean record = false; 34void draw() { 35 /* 36 background(); 37 translate(width*0.5, 0, 0); 38 rotateY(frameCount*0.01); 39 translate(-width*0.5, 0, 0); 40 image(pg, -width, -height); 41 */ 42 43 for (int i = 0; i \u0026lt; iterations; i++) { 44 getPoint(); 45 drawPoint(); 46 } 47 48 if (frameCount \u0026lt; 100) { 49 saveFrame(\u0026#34;frame-####.jpg\u0026#34;); 50 } else { 51 exit(); 52 } 53} 54 55void getPoint() { 56 57 float dx = 0; 58 float dy = 0; 59 60 float r1 = random(1); 61 if (r1 \u0026lt; 0.01) { 62 //1 63 dx = magicX[0][0]; 64 dy = magicY[0][0] * y; 65 } else if (r1 \u0026lt; 0.86 ) { 66 //2 67 dx = magicX[1][0] * x + magicX[1][1] * y; 68 dy = magicY[1][0] * x + magicY[1][1] * y + magicY[1][2]; 69 } else if (r1 \u0026lt; 0.93) { 70 //3 71 dx = magicX[2][0] * x + magicX[2][1] * y; 72 dy = magicY[2][0] * x + magicY[2][1] * y + magicY[2][2]; 73 } else { 74 //4 75 dx = magicX[3][0] * x + magicX[3][1] * y; 76 dy = magicY[3][0] * x + magicY[3][1] * y + magicY[3][2]; 77 } 78 79 x = dx; 80 y = dy; 81} 82 83int[][] histogram; 84int highest = 0; 85 86void drawPoint() { 87 88 int px = (int)map(x, -2.1820, 2.6558, width*0.19, width*0.81); 89 int py = (int)map(y, 0, 9.9983, height*0.99, height*0.01); 90 91 histogram[px][py]++; 92 93 if (histogram[px][py] \u0026gt; highest) { 94 highest = histogram[px][py]; 95 set(px, py, 255); 96 } 97 98 if (highest \u0026gt; 1) { 99 //float bright = map(histogram[px][py], 0, (float)Math.log(highest), 0, 255); 100 //stroke(histogram[px][py], bright,0); 101 float m = map(histogram[px][py], 0, log(highest), 0, 1); 102 color from = color(#123556); 103 color to = color(255); 104 color l = lerpColor(from, to, m); 105 106 // pixels[py*width+px] = l; 107 set(px, py, l); 108 } 109} Written using the Processing Java library: https://processing.org/download\n","link":"https://trimad.github.io/post/2018-06-28-barnsley-fern/","section":"post","tags":["animation","fractal"],"title":"Barnsley Fern"},{"body":" Distance formula 1 execution time: 2224ms Distance formula 2 execution time: 4ms Distance formula 3 execution time: 3ms ","link":"https://trimad.github.io/post/2018-04-17-comparing-java-distance-functions/","section":"post","tags":["distance"],"title":"Comparing Java Distance Functions"},{"body":"","link":"https://trimad.github.io/tags/distance/","section":"tags","tags":null,"title":"distance"},{"body":"","link":"https://trimad.github.io/tags/prime-numbers/","section":"tags","tags":null,"title":"prime numbers"},{"body":"","link":"https://trimad.github.io/tags/processing/","section":"tags","tags":null,"title":"processing"},{"body":" Launch this sketch is a new window (recommended) Launch p5.js web editor The Ulam Spiral or prime spiral is a graphical depiction of the set of prime numbers, devised by mathematician Stanislaw Ulam in 1963 and popularized in Martin Gardner's Mathematical Games column in Scientific American a short time later. It is constructed by writing the positive integers in a square spiral and specially marking the prime numbers.\nWhat I've done differently is allowed for iterating every integer in the grid forwards or backwards to search for long, connected diaganal lines of prime numbers in the grid. The framerate of the animation can be adjusted, as well as the \u0026quot;grid multiplier\u0026quot; which is how many cells to draw in each row and collumn. Double-clicking on the menu collapses it. There are also basic keyboard arrow controls:\nControls - LEFT ARROW = Step backward - RIGHT ARROW = Step forwards - UP ARROW = Pause - DOWN ARROW = Pause","link":"https://trimad.github.io/post/2018-05-17-ulam-sprial/","section":"post","tags":["prime numbers","processing","interactive"],"title":"Ulam Spiral"},{"body":"","link":"https://trimad.github.io/archives/","section":"archives","tags":null,"title":"Archives"},{"body":"","link":"https://trimad.github.io/tags/bipartite-graph/","section":"tags","tags":null,"title":"bipartite graph"},{"body":"","link":"https://trimad.github.io/categories/coding-challenge/","section":"categories","tags":null,"title":"Coding Challenge"},{"body":"","link":"https://trimad.github.io/tags/maximum-flow/","section":"tags","tags":null,"title":"maximum flow"},{"body":"","link":"https://trimad.github.io/tags/uva/","section":"tags","tags":null,"title":"uva"},{"body":"This is a maximum flow problem on a bipartite graph. I created the flow chart above to visualize the 3 test cases. The virtual judge run time was 0.18s.\nProblem Solution 1/* * * * * * * * 2Tristan Madden 32018-05-01 4https://onlinejudge.org/index.php?option=com_onlinejudge\u0026amp;Itemid=8\u0026amp;page=show_problem\u0026amp;problem=1986 5* * * * * * * * */ 6 7import java.io.BufferedReader; 8import java.io.IOException; 9import java.io.InputStreamReader; 10import java.util.Arrays; 11import java.util.HashMap; 12import java.util.LinkedList; 13import java.util.Queue; 14public class Main { 15 static int source = 0; 16 static int sink = 1; 17 static HashMap\u0026lt;String, Integer\u0026gt; map = new HashMap\u0026lt;\u0026gt;(6); 18 public static void main(String[] args) throws IOException { 19 map.put(\u0026#34;XS\u0026#34;, 2); 20 map.put(\u0026#34;S\u0026#34;, 3); 21 map.put(\u0026#34;M\u0026#34;, 4); 22 map.put(\u0026#34;L\u0026#34;, 5); 23 map.put(\u0026#34;XL\u0026#34;, 6); 24 map.put(\u0026#34;XXL\u0026#34;, 7); 25 BufferedReader br = new BufferedReader(new InputStreamReader(System.in)); 26 int testCases = Integer.parseInt(br.readLine()); 27 while (testCases-- \u0026gt; 0) { 28 String[] nm = br.readLine().split(\u0026#34; \u0026#34;); 29 //N is multiple of 6, 1 ‚â§ N ‚â§ 36 30 int N = Integer.parseInt(nm[0]); 31 //M, 1 ‚â§ M ‚â§ 30, indicates the number of volunteers, with N ‚â• M 32 int M = Integer.parseInt(nm[1]); 33 /* * * * * * * * * * * * * * * * * * * * * 34 |* The size of the graph will be the sum of: 35 |* -the number of shirt sizes available (6) 36 |* -the number of volunteers (M) 37 |* -the sink and source (2) 38 |* * * * * * * * * * * * * * * * * * * * */ 39 MyGraph graph = new MyGraph(M + 8); 40 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 41 |* S T E P O N E 42 |* Construct the edges from the source node to the t-shirt nodes. 43 |* The capacity of these edges will be N/6, or the number of t-shirts 44 |* in stock of this size. 45 |* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 46 int t; 47 for (t = 0; t \u0026lt; 6; t++) { 48 graph.addEdge(source, t + 2, N / 6); 49 } 50 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 51 |* S T E P T W O 52 |* Construct the edges from the t-shirt nodes to the volunteer nodes. 53 |* This is the bipartite graph. 54 |* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 55 int i, a, b; 56 for (i = 0; i \u0026lt; M; i++) { 57 String[] sizes = br.readLine().split(\u0026#34; \u0026#34;); 58 a = map.get(sizes[0]); 59 b = map.get(sizes[1]); 60 graph.addEdge(a, i + 8, 1); 61 graph.addEdge(b, i + 8, 1); 62 } 63 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 64 |* S T E P T H R E E 65 |* Construct the edges from the volunteer nodes to the sink node. 66 |* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 67 int v; 68 for (v = 0; v \u0026lt; M; v++) { 69 graph.addEdge(v + 8, sink, 1); 70 } 71 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 72 |* S T E P F O U R 73 |* Run Max Flow on the bipartite graph. 74 |* If the maximum flow is equal to the number of volunteers, print 75 |* \u0026#34;YES\u0026#34;. Otherwise, print \u0026#34;NO\u0026#34;. 76 |* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 77 if (graph.maxFlow(source, sink) == M) { 78 System.out.println(\u0026#34;YES\u0026#34;); 79 } else { 80 System.out.println(\u0026#34;NO\u0026#34;); 81 } 82 } 83 } 84} 85class MyGraph { 86 int size; 87 int[][] edges; 88 MyGraph(int _size) { 89 this.size = _size; 90 this.edges = new int[size][size]; 91 } 92 void addEdge(int x, int y, int weight) { 93 edges[x][y] += weight; 94 } 95 /* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * 96 |* M A X F L O W 97 |* This is a franken-method pieced together from other solution I found 98 |* online. Pretty much treating it as a black box. 99 |* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * */ 100 int maxFlow(int source, int sink) { 101 int[] prev = new int[size]; 102 int answer = 0; 103 int mincut = Integer.MAX_VALUE; //infinity 104 while (true) { 105 Queue\u0026lt;Integer\u0026gt; q = new LinkedList\u0026lt;\u0026gt;(); 106 q.add(source); 107 Arrays.fill(prev, -1); 108 while (!q.isEmpty() \u0026amp;\u0026amp; prev[sink] == -1) { 109 int u = q.remove(); 110 for (int v = 0; v \u0026lt; size; v++) { 111 if (v != source \u0026amp;\u0026amp; prev[v] == -1 \u0026amp;\u0026amp; edges[u][v] \u0026gt; 0) { 112 q.add(v); 113 prev[v] = u; 114 } 115 } 116 } 117 if (prev[sink] == -1) { 118 break; 119 } 120 int y = sink; 121 int x = prev[y]; 122 while (x != -1) { 123 mincut = Math.min(mincut, edges[x][y]); 124 y = x; 125 x = prev[y]; 126 } 127 int v = sink; 128 int u = prev[v]; 129 while (u != -1) { 130 edges[u][v] -= mincut; 131 edges[v][u] += mincut; 132 v = u; 133 u = prev[v]; 134 } 135 answer += mincut; 136 } 137 return answer; 138 } 139} ","link":"https://trimad.github.io/archives/2018-05-01-uva-11045/","section":"archives","tags":["uva","maximum flow","bipartite graph"],"title":"UVa Online Judge Challenge \"11045\""},{"body":"","link":"https://trimad.github.io/tags/kruskals-algorithm/","section":"tags","tags":null,"title":"kruskal's algorithm"},{"body":"","link":"https://trimad.github.io/post/2018-04-11-kruskal-algorithm-processing/","section":"post","tags":["kruskal's algorithm","minimum spanning tree"],"title":"Kruskal's Algorithm Visualized With Processing"},{"body":"","link":"https://trimad.github.io/tags/minimum-spanning-tree/","section":"tags","tags":null,"title":"minimum spanning tree"},{"body":"Problem My Solution 1import java.util.Scanner; 2 3public class Main { 4 5\tpublic static void main(String[] args) { 6 7\tScanner sc = new Scanner(System.in); 8 9\twhile (sc.hasNext()) { 10 11\tString temp[] = sc.nextLine().split(\u0026#34; \u0026#34;); 12\tif (Integer.parseInt(temp[0]) == 0 \u0026amp;\u0026amp; Integer.parseInt(temp[1]) == 0 \u0026amp;\u0026amp; Integer.parseInt(temp[2]) == 0 13\t\u0026amp;\u0026amp; Integer.parseInt(temp[3]) == 0) { 14 15\tbreak; 16\t} else { 17\tSystem.out.println(1080 + ((Integer.parseInt(temp[0]) - Integer.parseInt(temp[1]) + 40) % 40 18\t+ (Integer.parseInt(temp[2]) - Integer.parseInt(temp[1]) + 40) % 40 19\t+ (Integer.parseInt(temp[2]) - Integer.parseInt(temp[3]) + 40) % 40) * 9); 20\t} 21\t} 22 23\t} 24} ","link":"https://trimad.github.io/archives/2017-11-09-uva-10550/","section":"archives","tags":["uva"],"title":"UVa Online Judge Challenge \"10550\""},{"body":"","link":"https://trimad.github.io/tags/assembly/","section":"tags","tags":null,"title":"assembly"},{"body":"This MASM program demonstrates the use of procedures (functions) as well as printing different colors to console.\n","link":"https://trimad.github.io/post/2017-10-24-demonstrating-procedures-and-console-output/","section":"post","tags":["assembly"],"title":"Demonstrating Procedures and Console Output"},{"body":"","link":"https://trimad.github.io/categories/masm/","section":"categories","tags":null,"title":"MASM"},{"body":"This is my first attempt a prime sieve in assembly. It is largely a direct translation from a Sieve of Eratosthenes originally written in Java, so this program is not exactly optimally structured. Firstly, it stores all primes up to n in an array. Secondly, it counts the number of primes before n and stores that hexadecimal value in the EAX register. This is rough. There is much room for improvement, and I intend to revisit this program without using the MUL function.\n","link":"https://trimad.github.io/post/2017-10-17-sieve-of-eratosthenes/","section":"post","tags":["assembly","prime numbers"],"title":"Sieve of Eratosthenes"},{"body":"Problem My Solution 1import java.util.Scanner; 2 3public class Main { 4 5 public static void main(String[] args){ 6 7 Scanner sc = new Scanner(System.in); 8 9 boolean verticalMarks = false; 10 11 while (sc.hasNextLine()) { 12 13 StringBuilder sb = new StringBuilder(); 14 15 String input = sc.nextLine(); 16 17 for (int i = 0; i \u0026lt; input.length(); i++) { 18 19 if (input.charAt(i) == 34) { 20 21 if (!verticalMarks) { 22 23 sb.append(\u0026#34;``\u0026#34;); 24 25 verticalMarks = true; 26 27 } else if (verticalMarks) { 28 29 sb.append(\u0026#34;\u0026#39;\u0026#39;\u0026#34;); 30 31 verticalMarks = false; 32 33 } 34 35 } else { 36 37 sb.append(input.charAt(i)); 38 39 } 40 41 } 42 43 System.out.println(sb); 44 45 } 46 47 } 48 49} ","link":"https://trimad.github.io/archives/2017-10-17-uva-272/","section":"archives","tags":["uva"],"title":"UVa Online Judge Challenge \"272\""},{"body":"","link":"https://trimad.github.io/tags/fibonacci/","section":"tags","tags":null,"title":"fibonacci"},{"body":"This is my first x86 MASM program. As the title states, this program outputs a Fibonacci number that corresponds to an input value of n. I'm not happy with its current state because it is constantly swapping between the memory and registers.\n","link":"https://trimad.github.io/post/2017-10-07-nth-fibonacci-number/","section":"post","tags":["fibonacci","assembly"],"title":"Nth Fibonacci Number"},{"body":"Problem My Solution 1import java.io.IOException; 2import java.util.Scanner; 3 4public class Main { 5 6 public static void main(String[] args) throws IOException { 7 8 Scanner sc = new Scanner(System.in); 9 10 while (sc.hasNext()) { 11 12 int n1 = sc.nextInt(); 13 int n2 = sc.nextInt(); 14 15 if (n2 n1) { 16 int largest = 0; 17 18 for (int i = n1; i = n2; i++) { 19 int temp = collatz(i, 1); 20 if (temp largest) { 21 largest = temp; 22 } 23 } 24 25 System.out.println(n1 + + n2 + + largest); 26 } else if (n2 n1) { 27 int largest = 0; 28 29 for (int i = n2; i = n1; i++) { 30 int temp = collatz(i, 1); 31 if (temp largest) { 32 largest = temp; 33 } 34 } 35 System.out.println(n1 + + n2 + + largest); 36 } else if (n2 == n1) { 37 int temp = collatz(n1, 1); 38 System.out.println(n1 + + n2 + + temp); 39 } 40 41 } 42 } 43 44 public static int collatz(long input, int cycleLength) { 45 46 long n = input; 47 int counter = cycleLength; 48 49 if (n == 1) { 50 return counter; 51 } else if (n % 2 != 0) { 52 n = 3 n + 1; 53 counter++; 54 return collatz(n, counter); 55 } else { 56 n = n 2; 57 counter++; 58 return collatz(n, counter); 59 } 60 61 } 62} ","link":"https://trimad.github.io/archives/2017-10-05-uva-100/","section":"archives","tags":["uva"],"title":"UVa Online Judge Challenge \"100\""},{"body":"Problem My Solution 1import java.util.Scanner; 2 3public class Main { 4 5\tpublic static void main(String[] args) { 6 7\tScanner sc = new Scanner(System.in); 8 9\twhile (sc.hasNext()) { 10 11\tboolean light = true; 12\tlong n = sc.nextLong(); 13 14\tif (n == 0) { 15\tSystem.exit(0); 16\t} 17 18\tlong a = Math.round(Math.sqrt(n)); 19 20\tif ((a * a) == n) { 21\tlight = true; 22\t} else { 23\tlight = false; 24\t} 25 26\tif (light) { 27\tSystem.out.println(\u0026#34;yes\u0026#34;); 28\t} else { 29\tSystem.out.println(\u0026#34;no\u0026#34;); 30\t} 31 32\t} 33\t} 34} ","link":"https://trimad.github.io/archives/2017-10-05-uva-10110/","section":"archives","tags":["uva"],"title":"UVa Online Judge Challenge \"10110\""},{"body":"","link":"https://trimad.github.io/tags/kattis/","section":"tags","tags":null,"title":"kattis"},{"body":"Problem My solution 1import java.util.Scanner; 2public class Parking { 3 public static void main(String[] args) { 4 Scanner sc = new Scanner(System.in); 5 int t = sc.nextInt(); 6 for (int i = 0; i \u0026lt; t; i++) { 7 int n = sc.nextInt(); 8 int high = 0; 9 int low = 100; 10 int d = 0; 11 for (int j = 0; j \u0026lt; n; j++) { 12 int s = sc.nextInt(); 13 if (s \u0026gt; high) { 14 high = s; 15 } 16 if (s \u0026lt; low) { 17 low = s; 18 } 19 d = (high - low) * 2; 20 } 21 System.out.println(d); 22 } 23 } 24} ","link":"https://trimad.github.io/archives/2017-09-15-kattis-parking2/","section":"archives","tags":["kattis"],"title":"Kattis Challenge \"Parking\""},{"body":"Problem My solution 1import java.util.Scanner; 2public class SumOfOthers { 3 public static void main(String[] args) { 4 Scanner sc = new Scanner(System.in); 5 while (sc.hasNext()) { 6 String[] temp = sc.nextLine().split(\u0026#34; \u0026#34;); 7 int answer = 0; 8 for (int i = 0; i \u0026lt; temp.length; i++) { 9 answer += Integer.parseInt(temp[i]); 10 } 11 System.out.println(answer/2); 12 } 13 } 14} ","link":"https://trimad.github.io/archives/2017-09-15-kattis-sum-of-others/","section":"archives","tags":["kattis"],"title":"Kattis Challenge \"Sum of Others\""},{"body":"Problem My solution 1import java.util.Scanner; 2 3class Main { 4 5 public static void main(String[] args) { 6 7 int a, b, t; 8 9 Scanner sc = new Scanner(System.in); 10 t = sc.nextInt(); 11 sc.nextLine(); 12 13 while (t \u0026gt; 0) { 14 String temp = sc.nextLine(); 15 String[] str_array = temp.split(\u0026#34; \u0026#34;); 16 a = Integer.parseInt(str_array[0]); 17 b = Integer.parseInt(str_array[1]); 18 19 if (a \u0026gt; b) { 20 System.out.println(\u0026#34;\u0026gt;\u0026#34;); 21 } else if (a \u0026lt; b) { 22 System.out.println(\u0026#34;\u0026lt;\u0026#34;); 23 } else { 24 System.out.println(\u0026#34;=\u0026#34;); 25 } 26 t--; 27 } 28 } 29} ","link":"https://trimad.github.io/archives/2017-08-24-uva-11172/","section":"archives","tags":["uva"],"title":"UVa Online Judge Challenge \"11172\""},{"body":"Problem My solution 1import java.util.ArrayList; 2import java.util.Scanner; 3 4public class KattisA { 5 6 public static void main(String[] args) { 7 8 Scanner sc = new Scanner(System.in); 9 int N = sc.nextInt(); 10 11 boolean incr = false; 12 boolean decr = false; 13 14 ArrayList\u0026lt;String\u0026gt; al = new ArrayList(); 15 16 for (int i = 0; i \u0026lt;= N; i++) { 17 al.add(sc.nextLine()); 18 } 19 20 for (int i = 1; i \u0026lt; al.size() - 1; i++) { 21 22 //Increasing 23 if (al.get(i).charAt(0) \u0026lt; al.get(i + 1).charAt(0)) { 24 incr = true; 25 } 26 //Decreasing 27 if (al.get(i).charAt(0) \u0026gt; al.get(i + 1).charAt(0)) { 28 decr = true; 29 } 30 31 //If the first characters are equal, check the next character 32 if (al.get(i).charAt(0) == al.get(i + 1).charAt(0)) { 33 //Increasing 34 if (al.get(i).charAt(1) \u0026lt; al.get(i + 1).charAt(1)) { 35 incr = true; 36 } 37 //Decreasing 38 if (al.get(i).charAt(1) \u0026gt; al.get(i + 1).charAt(1)) { 39 decr = true; 40 } 41 } 42 43 } 44 45 if (decr \u0026amp;\u0026amp; !incr) { 46 System.out.println(\u0026#34;DECREASING\u0026#34;); 47 } else if (!decr \u0026amp;\u0026amp; incr) { 48 System.out.println(\u0026#34;INCREASING\u0026#34;); 49 } else if ((incr \u0026amp;\u0026amp; decr) || (!incr \u0026amp; !decr)) { 50 System.out.println(\u0026#34;NEITHER\u0026#34;); 51 } 52 53 } 54} ","link":"https://trimad.github.io/archives/2017-08-18-kattis-line-them-up/","section":"archives","tags":["kattis"],"title":"Kattis Challenge \"Line Them Up\""},{"body":"Problem My solution 1import java.util.Scanner; 2 3public class KattisC { 4 5 public static void main(String[] args) { 6 7 Scanner sc = new Scanner(System.in); 8 9 while (sc.hasNext()) { 10 11 String[] nT = new String[2]; 12 13 nT = sc.nextLine().split(\u0026#34; \u0026#34;); 14 15 int n = Integer.parseInt(nT[0]); 16 int T = Integer.parseInt(nT[1]); 17 18 int counter = 0; 19 int sum = 0; 20 21 String[] posInts = new String[30]; 22 23 posInts = sc.nextLine().split(\u0026#34; \u0026#34;); 24 25 while (counter \u0026lt; n) { 26 27 sum += Integer.parseInt(posInts[counter]); 28 29 if (sum \u0026gt; T) { 30 31 break; 32 } 33 counter++; 34 35 } 36 37 System.out.println(counter); 38 } 39 } 40} ","link":"https://trimad.github.io/archives/2017-08-18-kattis-server/","section":"archives","tags":["kattis"],"title":"Kattis Challenge \"Server\""},{"body":"Problem My solution 1import java.util.Scanner; 2 3public class Kattis { 4 5 public static void main(String[] args) { 6 7 Scanner sc = new Scanner(System.in); 8 9 while (sc.hasNext()) { 10 11 long X = sc.nextLong(); 12 long Y = sc.nextLong(); 13 14 if (X \u0026gt; Y) { 15 System.out.println(Math.abs(X - Y)); 16 17 } else { 18 System.out.println(Math.abs(X - Y)); 19 20 } 21 } 22 } 23} ","link":"https://trimad.github.io/archives/2017-08-15-kattis-different/","section":"archives","tags":["kattis"],"title":"Kattis Challenge \"A Different Problem\""},{"body":"","link":"https://trimad.github.io/tags/counting-sort/","section":"tags","tags":null,"title":"counting sort"},{"body":"Counting sort is a non-comparison based sorting algorithm that works by determining, for each element in an input array, the number of elements that are less than it. This information is then used to place the element in its correct position in the output array. The algorithm has a linear time complexity of O(n+k), where n is the number of elements in the input array and k is the range of values in the input array.\n1//int [] A = {2, 5, 3, 0, 2, 3, 0, 3}; 2int [] A = {6, 0, 2, 0, 1, 3, 4, 6, 1, 3, 2}; 3int []B = new int[A.length]; 4 5void setup() { 6 countingSort(A); 7 noLoop(); 8} 9 10void countingSort(int arr[]) { 11 12 int k = arr.length; 13 14 // The output character array that will have sorted arr 15 int output[] = new int[k]; 16 17 // Create a count array to store count of inidividual 18 // characters and initialize count array as 0 19 int count[] = new int[256]; 20 for (int i=0; i\u0026lt;256; ++i) 21 count[i] = 0; 22 23 // store count of each character 24 for (int i=0; i\u0026lt;k; ++i) { 25 ++count[arr[i]]; 26 print(count[i]); 27 } 28 // Change count[i] so that count[i] now contains actual 29 // position of this character in output array 30 for (int i=1; i\u0026lt;=255; ++i) { 31 count[i] += count[i-1]; 32 } 33 println(\u0026#34;\u0026#34;); 34 // Build the output character array 35 for (int i = 0; i\u0026lt;k; ++i) 36 { 37 output[count[arr[i]]-1] = arr[i]; 38 print(output[i]); 39 --count[arr[i]]; 40 } 41 println(\u0026#34;\u0026#34;); 42 // Copy the output array to arr, so that arr now 43 // contains sorted characters 44 for (int i = 0; i\u0026lt;k; ++i) { 45 arr[i] = output[i]; 46 print(output[i]); 47 } 48} ","link":"https://trimad.github.io/post/2017-07-18-counting-sort/","section":"post","tags":["sorting","counting sort"],"title":"Counting Sort"},{"body":"","link":"https://trimad.github.io/tags/sorting/","section":"tags","tags":null,"title":"sorting"},{"body":"","link":"https://trimad.github.io/tags/javascript/","section":"tags","tags":null,"title":"JavaScript"},{"body":"","link":"https://trimad.github.io/tags/p5.js/","section":"tags","tags":null,"title":"p5.js"},{"body":"This sketch maps perlin noise between a value of 0 and 255 across a grid. Values greater than or equal to 100 are \u0026quot;grass\u0026quot;, values between 75 and 100 are \u0026quot;sand\u0026quot;, and values less than or equal to 75 are \u0026quot;water\u0026quot;.\nclick mouse in iframe to generate a new map Edit This Sketch","link":"https://trimad.github.io/post/2017-07-16-simple-2d-perlin-noise/","section":"post","tags":["interactive","JavaScript","p5.js"],"title":"Simple 2D Terrain Generation Using Perlin Noise"},{"body":"click on them circles homes\nEdit This Sketch ","link":"https://trimad.github.io/post/2016-12-13-arrays/","section":"post","tags":["interactive"],"title":"Arrays"},{"body":"Made you look.\n","link":"https://trimad.github.io/about/","section":"","tags":null,"title":"About Me"},{"body":"","link":"https://trimad.github.io/series/","section":"series","tags":null,"title":"Series"}]